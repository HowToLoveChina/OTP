C51 COMPILER V9.01   SM4PROCESS                                                            11/23/2016 11:58:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SM4PROCESS
OBJECT MODULE PLACED IN .\ObjFile\SM4Process.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Frame\SM4Process.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcF
                    -ile\Frame\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND 
                    -PRINT(.\LstFile\SM4Process.lst) OBJECT(.\ObjFile\SM4Process.obj)

line level    source

   1          #include "SM4.h"
   2          #include "stddef.h"
   3          #include "string.H"
   4          #include "SM4Process.h"
   5          #include "ScuFunc.h"
   6          #include "Sha1.h"
   7          //#include "SM3.h"
   8          
   9          void memxor(void *pu1Output, const void *pu1Input, u2 u2Len)
  10          {
  11   1              unsigned char   *pOutput;
  12   1              unsigned char   *pInput;
  13   1              unsigned short  u2Index;
  14   1              
  15   1              pOutput = (unsigned char*)pu1Output;
  16   1              pInput =  (unsigned char*)pu1Input;
  17   1              for ( u2Index = 0; u2Index < u2Len; u2Index++ )
  18   1              {
  19   2                      if ( ((void *)0) == pInput )
  20   2                      {
  21   3                              *pOutput++ ^= 0xFF;
  22   3                      }
  23   2                      else
  24   2                      {
  25   3                              *pOutput++ ^= *pInput++;
  26   3                      }
  27   2              }
  28   1              return;
  29   1      }
  30          
  31          void Xrmemcpy(void *pu1Output, const void *pu1Input, unsigned short u2Len)
  32          {
  33   1              unsigned char   *pOutput;
  34   1              unsigned char   *pInput;
  35   1              
  36   1              pOutput = (unsigned char*)pu1Output + u2Len;
  37   1              pInput = (unsigned char*)pu1Input + u2Len;
  38   1              while ( pOutput > (unsigned char*)pu1Output )
  39   1              {
  40   2                      *(--pOutput) = *(--pInput);
  41   2              }
  42   1              return;
  43   1      }
  44          
  45          #if 1
  46          void AlgSymmMacFun2(u1 * pu1Data, u2 *pu2DataSize, u1 *pu1KeyVal,  u1* pu1IV)   //,u1 u1FinalFlag)
  47          {
  48   1              u1                      u1BlockSize;
  49   1          u2          u2DataSize;
  50   1      
  51   1              vScu_SetSysClkOsc2M();
  52   1          u2DataSize = *pu2DataSize;
  53   1      
C51 COMPILER V9.01   SM4PROCESS                                                            11/23/2016 11:58:15 PAGE 2   

  54   1              //vSMS4SetKey(pu1KeyVal,0x10);
  55   1              SM4_Init(pu1KeyVal);
  56   1              u1BlockSize = 0x10;
  57   1              
  58   1                      while ( u2DataSize >= u1BlockSize )
  59   1                      {
  60   2                              memxor(pu1IV,pu1Data,u1BlockSize);
  61   2      
  62   2                              //if ( ALGID_SMS4 == u1AlgID )
  63   2                              {
  64   3                                      //vSMS4EncDec(pu1IV,pu1IV,0x00);
  65   3                                      SM4_Crypto(pu1IV,0x10, 0x00,0x00,NULL,pu1IV);
  66   3                              }
  67   2      
  68   2      
  69   2                              pu1Data += u1BlockSize;
  70   2                              u2DataSize -= u1BlockSize;
  71   2                      }
  72   1                      // ÅÐ¶ÏÊÇ·ñÊÇ×îºóÒ»¸ö·Ö×é£¬Èç¹ûÊÇ£¬ÔòÐèÒª²¹×ãºó¼ÆËã
  73   1                      //if ( u1FinalFlag )
  74   1                      {
  75   2      
  76   2                              //if ( ALGID_SMS4 == u1AlgID )
  77   2                              {
  78   3                                      //vSMS4SetKey(pu1KeyVal,0x10);
  79   3                                      SM4_Init(pu1KeyVal);
  80   3                              }
  81   2      
  82   2                              memxor(pu1IV,pu1Data,(u1)u2DataSize);
  83   2                              pu1IV[(u1)u2DataSize] ^= 0x80;
  84   2      
  85   2                              //if ( ALGID_SMS4 == u1AlgID )
  86   2                              {
  87   3                                      SM4_Crypto(pu1IV,0x10, 0x00,0x00,NULL,pu1IV);                   //Õâ¸ö³¤¶ÈÊÇ16×Ö½ÚÂëå
  88   3                              }
  89   2      
  90   2                      }
  91   1                      //vScu_SetSysClk32K();          //9600_test
  92   1                      vScu_SetSysClk64K();
  93   1                      return;
  94   1              
  95   1      }
  96          #endif
  97          
  98          #if 0
              u2 GenOtpSeed(u1 *pu1OutSeed,u1 *pu1SeedKey,u1 *pu1MacKey,u1 *pu1RandData)
              {
                      u1      pu1IV[16];
                      u1      pu1Buf[9];
                      u2      u2Len;
              
                      // ¼ÆËãMAC
                      memset(pu1IV, 0x00, 0x10);
                      u2Len = 18;
                      AlgSymmMacFun2(pu1RandData, u2Len, pu1MacKey, pu1IV);                   //      Ëãmac
              
                      //Byte2Num(pu1Buf, 8, pu1IV, 4);  // 8×Ö½ÚMAC           ?
                      if (0 != memcmp(pu1RandData+18,pu1Buf+4,4))                     //0716  18Òª¸Ä?
                      {
                              return 1;
                      }
                      // ¼ÆËã±£´æSEED
C51 COMPILER V9.01   SM4PROCESS                                                            11/23/2016 11:58:15 PAGE 3   

                      // ÏÈSM3
                      u2Len = SM3Hash(pu1RandData, 18, gUserInfo);                    //0716  18Òª¸Ä?
                      // ÔÙSMS4
                      AlgSymmEncDecFun1(pu1OutSeed, &u2Len, pu1SeedKey, ALGID_SMS4, ALG_MODE_ECB, NULL, 0x00, 0x01);
                      
                      return 0;
              }
              #endif
 124          
 125          #if 0
              u1 SM4ENC_TEST(void)                            //SM4¼ÓÃÜ×Ô¼ìº¯Êý
              {
                      u1 i;
                      u1 xdata g_u1Key[16] = {0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
             -                //µÈ´ý¼ÓÃÜµÄÊý¾Ý
                      u1 xdata pu1MacKey[16] = {0x53,0x66,0x47,0xcf,0x5a,0xb0,0x51,0x1d,0x81,0x03,0xfe,0xe9,0x74,0x5f,0x17,0x34
             -};        //ÃÜÔ¿
                      u1 xdata u1Result[16] = {0x67,0x0f,0x58,0xb1,0x78,0xf1,0x5c,0x3a,0x08,0xc5,0xcb,0xdb,0x49,0x82,0x06,0x10}
             -;                //Ó¦¸ÃµÃµ½µÄ½á¹û
                      
                      SM4_Init(pu1MacKey);            //³õÊ¼»¯ÃÜÔ¿
                      SM4_Crypto(g_u1Key,16,0x00,0x00,NULL,g_u1Key);                  //¼ÓÃÜ²âÊÔ
              
                      for(i=0;i<16;i++)
                      {
                              if(g_u1Key[i]!=u1Result[i])
                              {
                                      break;
                              }
                      }
              
                      if(i==16)
                      {
                              return 0;
                      }
                      else
                      {
                              return 0xff;
                      }
              }
              #endif
 154          u1 SM4DEC_TEST(void)                            //SM4½âÃÜ×Ô¼ìº¯Êý
 155          {
 156   1              u1 i;
 157   1              u1 xdata g_u1Key[16] = {0x67,0x0f,0x58,0xb1,0x78,0xf1,0x5c,0x3a,0x08,0xc5,0xcb,0xdb,0x49,0x82,0x06,0x10};
             -                //µÈ´ý½âÃÜµÄÊý¾Ý
 158   1              u1 xdata pu1MacKey[16] = {0x53,0x66,0x47,0xcf,0x5a,0xb0,0x51,0x1d,0x81,0x03,0xfe,0xe9,0x74,0x5f,0x17,0x34
             -};        //ÃÜÔ¿
 159   1              u1 xdata u1Result[16] =         {0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
             -};                //Ó¦¸ÃµÃµ½µÄ½á¹û
 160   1              SM4_Init(pu1MacKey);            //³õÊ¼»¯ÃÜÔ¿
 161   1              SM4_Crypto(g_u1Key,16,0x01,0x00,NULL,g_u1Key);                  //½âÃÜ²âÊÔ
 162   1      
 163   1              for(i=0;i<16;i++)
 164   1              {
 165   2                      if(g_u1Key[i]!=u1Result[i])
 166   2                      {
 167   3                              break;
 168   3                      }
 169   2              }
 170   1      
 171   1              if(i==16)
C51 COMPILER V9.01   SM4PROCESS                                                            11/23/2016 11:58:15 PAGE 4   

 172   1              {
 173   2                      return 0;
 174   2              }
 175   1              else
 176   1              {
 177   2                      return 0xff;
 178   2              }
 179   1      }
 180          
 181          u1 SHA1_TEST(void)
 182          {
 183   1              u1 pu1In[10] = {0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19};
 184   1              u1 u1Result[20] = {0x49,0xCA,0xD5,0x1D,0xF8,0x2D,0x5C,0x73,0x97,0xB0,0x06,0xB0,0x6A,0xB1,0x21,0x40,0x1B,0
             -x18,0x63,0x56};
 185   1              u2 u2Len = 10;
 186   1              u1 pu1O[20];
 187   1              u1 i;
 188   1              
 189   1              SHA1Data(pu1O, pu1In, u2Len);
 190   1      
 191   1              for(i=0;i<20;i++)
 192   1              {
 193   2                      if(pu1O[i]!=u1Result[i])
 194   2                      {
 195   3                              break;
 196   3                      }
 197   2              }
 198   1      
 199   1              if(i==20)
 200   1              {
 201   2                      return 0;
 202   2              }
 203   1              else
 204   1              {
 205   2                      return 0xff;
 206   2              }
 207   1              
 208   1      }
 209          #if 0
              u1 SM3_TEST(void)                               //SM3×Ô¼ìº¯Êý
              {
                      u1 i;
                      u1 xdata out[32];
                      u1 xdata InBuff[64] = 
                      {
                              0x37,0x93,0x26,0x6b,0xfa,0x6c,0xe4,0xdb,0x6c,0x90,0x34,0x44,0xed,0x2b,0x05,0xa8,
                              0xeb,0xdf,0x25,0xc5,0x4f,0x5e,0x76,0x83,0x59,0x73,0x6b,0xfd,0xb5,0xd2,0x90,0x87,
                              0xb3,0xb7,0x18,0xb1,0xbc,0x7b,0x10,0x99,0x73,0x1a,0xf2,0xa2,0xb4,0x6a,0xee,0xea,
                              0x52,0x57,0x37,0x52,0x12,0x10,0x5c,0xfd,0xb3,0x6b,0x9b,0x6d,0x9b,0x0b,0xb1,0xf6
                      };
                      u1 u1Result[32] = 
                      {
                              0x74,0x40,0xFD,0x2A,0xD0,0xA6,0x81,0xC7,0xD7,0x51,0xD7,0x0B,0xBF,0xDE,0x94,0x53,
                              0x21,0xD8,0x39,0x1E,0x36,0x12,0x90,0xAB,0x92,0x26,0x93,0xB9,0x30,0x94,0x8E,0xBB
                      };
              
                      SM3_Hash(InBuff,64,out);                        //¹þÏ£²âÊÔ
              
                      for(i=0;i<32;i++)
                      {
                              if(out[i]!=u1Result[i])
                              {
C51 COMPILER V9.01   SM4PROCESS                                                            11/23/2016 11:58:15 PAGE 5   

                                      break;
                              }
                      }
              
                      if(i==32)
                      {
                              return 0;
                      }
                      else
                      {
                              return 0xff;
                      }
              }
              #endif
 247          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    926    ----
   CONSTANT SIZE    =     78    ----
   XDATA SIZE       =   ----     141
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
