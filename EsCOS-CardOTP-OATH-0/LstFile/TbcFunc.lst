C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TBCFUNC
OBJECT MODULE PLACED IN .\ObjFile\TbcFunc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Func\TbcFunc.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFile\
                    -Frame\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PRIN
                    -T(.\LstFile\TbcFunc.lst) OBJECT(.\ObjFile\TbcFunc.obj)

line level    source

   1          /********************************************************************
   2                                    Nationz Co.,Ltd
   3                  Copyright (c) 2009-2015 All Rights Reserved
   4           ********************************************************************
   5          File: TbcFunc.c
   6          History:
   7          Version                      Author                     Date
   8          V0.1                         nationz              2013-03-27
   9          
  10          Description:
  11               TbcFunc Source Code File;
  12          Function list:
  13              void vTbcInit(void);
  14              UINT32 ulGetTbcCountVlaue(void);
  15              void vTBC_ADJ(float ppm);
  16              float fCalFreqDrift(float Temp);    
  17          Special statement:
  18               NULL
  19           *******************************************************************/
  20          #define _TBCFUNC_C_
  21          #include "TBCFUNC.H"
  22          #include "SCUFUNC.H"
  23          #include "OTPFUNC.H"
  24          #include "math.h"
  25          #include "ADCFUNC.H"
  26          #include "UARTFUNC.H"
  27          
  28          /*************************外界温度表***************************/ 
  29          float code g_TempValue[Temp_LEN] = {  -25.0, -20.0, -15.0, -10.0, -7.0, -3.0,  \
  30                                                    0.0,   5.0,   7.0,  10.0,  15.0,  20.0,  25.0,  30.0, 35.0, 38.0
             -, \
  31                                                    40.0, 43.0,  47.0,  50.0,  53.0,  57.0,  60.0,  63.0, 67.0, \
  32                                                    70.0, 75.0,  80.0                                             
  33                                               };       
  34          
  35          /*************************PPM补偿值表***************************/                                     
  36          float code g_CompValue[Temp_LEN] = {      -76.0, -62.0, -49.0, -38.0, -31.5, -23.5, -19.0,  \
  37                                                                                            -12.0, -10.5, -7.5, -3.0, -1.0, 0.0, -1.5, -4.5, -7.0, -8.5,\
  38                                                                                            -11.5, -17.5, -22.0, -27.0, -34.5, -42.5, -48.5, -60.0, -70.0, -86.0, -105.0
  39                                                                                   };  
  40          
  41          /*************************实际温度补偿表***************************/
  42          float code g_RealValue[10][7] = {
  43                                                                                  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,
  44                                                                                  -3.0, -0.5, 0.0,  2.0,  2.0,  2.5,  3.0,
  45                                                                                  -2.5, -1.0, 0.5,  1.5,  2.4,  3.0,  3.5,
  46                                                                                  -3.5, -2.5, -0.5, 0.0,  1.4,  2.0,  2.5,
  47                                                                                  -4.5, -3.5, -3.0, -1.5, -2.5, -2.0, -2.0,
  48                                                                                  -5.0, -4.0, -3.5, -2.0, -2.5, -2.5, -2.5,
  49                                                                                  -6.0, -4.5, -3.5, -3.0, -2.5, -2.5, -2.5,
  50                                                                                  -7.0, -6.0, -5.0, -4.5, -4.0, -3.5, -3.5,
  51                                                                                  -8.5, -7.5, -6.0, -5.0, -5.0, -4.5, -4.5,       
  52                                                                                  -9.5, -8.5, -7.0, -6.5, -6.0, -5.5, -5.5        
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 2   

  53                                                                          };
  54          
  55          UINT8 idata _TEMP_INDEX_FLAG_        _at_ 0xb2;      //选择哪个温度作为另外一个计算的温度的标志位
  56          UINT8 idata _TEMP_COM_FLAG_          _at_ 0xb3;      //温度匹配标志位
  57          float idata _LAST_COM_VALUE_         _at_ 0xb4;      //上次得到的补偿值
  58          UINT8 idata WT_TenMin_Flag           _at_ 0xb8;      //十分钟补偿标志位
  59          UINT8 idata WT_TenMin_Couter         _at_ 0xb9;      //十分钟补偿计数器
  60          UINT8 idata WT_Onehour_Flag          _at_ 0xba;      //一小时定时唤醒标志位
  61          UINT8 idata Exral_Temp_Flag          _at_ 0xbb;         //温度超过可控范围
  62          UINT8 idata Basic_Temp_Cmd           _at_ 0xbc;         //基准温度校准指令
  63          UINT8 idata CompValue_Flag           _at_ 0xbd;         //实际温度校准索引
  64          float idata Crystal_PPM              _at_ 0xbe;      //晶振PPM
  65          UINT16 idata Bak_PPMValue            _at_ 0xc2;      //晶振PPM值备份
  66          UINT32 idata gBackupTBCInitVal       _at_ 0xc4;      //备份TBC上一次的值
  67          UINT16 idata Basic_Temp_Value        _at_ 0xc8;      //基准温度
  68          
  69          UINT8 idata Real_Temp_Value_H        _at_ 0xca;      //第一次实际采集温度
  70          UINT8 idata Real_Temp_Value_L        _at_ 0xcb;      //第一次实际采集温度
  71          
  72          float xdata Temporary[Temp_LEN];  //临时存储的温度值数组
  73          
  74          /********************************************************************
  75          Function name:       vTbcInit
  76          Input parameters:
  77              void
  78          Return:
  79              void
  80          Function:
  81              Enable TBC Module.
  82          ********************************************************************/
  83          void vTbcInit(void)
  84          {
  85   1              vScu_TbcClkEn();
  86   1              //vTbc_StartDis();//清TBC 计数器，
  87   1              //1HZ中断
  88   1              //vScu_TbcWakeupEn();
  89   1      
  90   1              vScu_TbcIntEn();
  91   1              //vTbc_Int1HzEn();
  92   1              //vTbc_StartEn();       
  93   1              
  94   1              ET0=1;
  95   1              EA=1;           
  96   1      }
  97          
  98          UINT32 Base_Time(void)
  99          {
 100   1          UINT32 base_time;
 101   1          //vScu_SetSysClk32K();
 102   1          vTbc_ReadBakCounter();
 103   1          
 104   1          base_time = ulGetTbcCountVlaue();
 105   1          if(base_time >= gBackupTBCInitVal)
 106   1          {
 107   2              base_time = base_time - gBackupTBCInitVal;
 108   2          }
 109   1          else
 110   1          {
 111   2              base_time = 0xFFFFFFFF + base_time - gBackupTBCInitVal;
 112   2          }
 113   1      
 114   1          return base_time;
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 3   

 115   1      }
 116          
 117          /********************************************************************
 118          Function name:       ulGetTbcCountVlaue
 119          Input parameters:
 120              void
 121          Return:
 122              UINT32 :TBC Counter Value
 123          Function:
 124              Get TBC Counter Value.
 125          ********************************************************************/
 126          #if 0
              UINT32 ulGetTbcCountVlaue(void)
              {
                      UINT32 TmpValue;
                      return TBC_COUNT_VALUE;         
              }
              #endif
 133          
 134          /********************************************************************
 135          Function name:     vScu_WakeUpTimerWakeUp_1Hour
 136          Input parameters:
 137              void
 138          Return:
 139              void
 140          Function:
 141              WakeUp 1Hour.
 142          ********************************************************************/
 143          void vScu_WakeUpTimerWakeUp_1Hour(void)
 144          { 
 145   1              // Open Enable and TBC
 146   1              //vTbcInit();                                   
 147   1              
 148   1              vScu_SetTimerWakeup_1H();       // Wakeup Time 1H                        
 149   1              vScu_WtWakeupEn();              //中断状态位使能
 150   1              vScu_TimerWakeupEn();           // Enable Wakeup Timer
 151   1              
 152   1              ET1=1;
 153   1              EA=1;   
 154   1      }
 155          
 156          /********************************************************************
 157          Function name:     vScu_WakeUpTimerWakeUp_1Min
 158          Input parameters:
 159              void
 160          Return:
 161              void
 162          Function:
 163              WakeUp 10Min.
 164          ********************************************************************/
 165          void vScu_WakeUpTimerWakeUp_1Min(void)
 166          { 
 167   1              // Open Enable and TBC
 168   1              //vTbcInit();                           
 169   1                       
 170   1              vScu_SetTimerWakeup_1M();       // Wakeup Time 60S                       
 171   1              vScu_WtWakeupEn();              //中断状态位使能                        
 172   1              vScu_TimerWakeupEn();           // Enable Wakeup Timer
 173   1              
 174   1              ET1=1;
 175   1              EA=1;   
 176   1      }
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 4   

 177          
 178          /********************************************************************
 179          Function name:       vTBC_ADJ
 180          Input parameters:
 181              float ppm :The Frequence Drift of Crystal with Temprature
 182          Return:
 183              void
 184          Function:
 185              frequency compensation.
 186          ********************************************************************/
 187          void vTBC_ADJ(float ppm)  
 188          {
 189   1              INT16 AdjValue;    
 190   1              
 191   1              AdjValue=(ppm*2); 
 192   1          
 193   1              if(ppm>=0) //gain time
 194   1              {
 195   2                       TBCADJL=(UINT8)((0x7FFF+AdjValue));
 196   2                   TBCADJH=(UINT8)((0x7FFF+AdjValue)>>8);          
 197   2              }
 198   1              else //losing time      根据32.768K的晶体频率温度曲线，在25C°附近PPM均为负
 199   1              {            
 200   2                       AdjValue=(~abs(AdjValue)+1); 
 201   2                       TBCADJL=(UINT8)((0x7FFF+AdjValue));
 202   2                   TBCADJH=(UINT8)((0x7FFF+AdjValue)>>8);                  
 203   2              }
 204   1      }
 205          
 206          /********************************************************************
 207          Function name:       void vTEMPVALUE_FIND(void)
 208          Input parameters:
 209              void  
 210          Return:
 211              void
 212          Function:
 213              Find the nearset temperature value  
 214          ********************************************************************/
 215          UINT8 vTempValue_Find(float Temp)
 216          {
 217   1          UINT8 u1Index1,temp_index,u1Index2;
 218   1          float Temp1,Temp2;
 219   1      //    float xdata Temporary[Temp_LEN];  //临时存储的温度值数组
 220   1          
 221   1          u1Index1 = 0xFF;
 222   1          u1Index2 = 0xFF;
 223   1          temp_index = 0;
 224   1      
 225   1          /***************************找出第一温度值索引************************************/
 226   1      
 227   1          Temp = (float)((int)(Temp*10))/10;     //温度取小数点后一位
 228   1          
 229   1          for(u1Index1 = 0; u1Index1 < Temp_LEN; u1Index1++)
 230   1          {
 231   2              if(g_TempValue[u1Index1] == Temp)
 232   2              {
 233   3                  _TEMP_COM_FLAG_ = 1;    //温度匹配到，不需要得到第一温度和第二温度进行计算
 234   3                  return u1Index1;
 235   3              }
 236   2              else
 237   2              {
 238   3                  _TEMP_COM_FLAG_ = 0;    //温度没匹配到，需要得到第一温度和第二温度进行计算
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 5   

 239   3                  
 240   3                  Temporary[temp_index++] = fabs(g_TempValue[u1Index1]-Temp);  //将差值绝对值存储在数组中   
 241   3              }
 242   2          }
 243   1      
 244   1          for(u1Index1 = 0; u1Index1 < Temp_LEN; u1Index1++)  //找出第一温度索引
 245   1          {
 246   2              if(Temporary[u1Index1] <= Temporary[0])
 247   2              {
 248   3                  Temporary[0] = Temporary[u1Index1];
 249   3                              u1Index2 = u1Index1;
 250   3              }
 251   2          }
 252   1          
 253   1          /***************************找出第二温度值索引************************************/
 254   1          if(u1Index2 == 0)                   //索引为0的温度的处理    
 255   1          {
 256   2              _TEMP_INDEX_FLAG_ = 1;
 257   2          }
 258   1          else if(u1Index2 == Temp_LEN)       //索引为最大值Temp_LEN的温度的处理 
 259   1          {
 260   2              _TEMP_INDEX_FLAG_ = 0;
 261   2          }
 262   1          else
 263   1          {
 264   2              Temp1 = Temporary[u1Index2-1];
 265   2                      Temp2 = Temporary[u1Index2+1]; 
 266   2      
 267   2              if(Temp1 <= Temp2)
 268   2              {
 269   3                  _TEMP_INDEX_FLAG_ = 0;      //选择g_TempValue[u1Index-1]作为第二温度
 270   3              }
 271   2              else
 272   2              {
 273   3                  _TEMP_INDEX_FLAG_ = 1;      //选择g_TempValue[u1Index+1]作为第二温度
 274   3              }        
 275   2          }
 276   1          
 277   1          return u1Index2;
 278   1      }
 279          
 280          
 281          /********************************************************************
 282          Function name:       void vCOPMVALUE_FIND(void)
 283          Input parameters:
 284              void  
 285          Return:
 286              void
 287          Function:
 288              Find the nearset compensation value  
 289          
 290              所检测到的温度 - 第一温度       所述特征值 - 第一特征值
 291              --------------------------  =  -------------------------
 292                 第二温度 - 第一温度          第二特征值 - 第一特征值
 293          ********************************************************************/
 294          float vCompValue_Find(float Temp,UINT8 index)
 295          {
 296   1          float TbcValue;
 297   1          float TemVar1,TemVar2,TemVar3;
 298   1          float TemVar4,TemVar5,TemVar6;
 299   1          
 300   1          if(_TEMP_COM_FLAG_ == 1)
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 6   

 301   1          {
 302   2              _TEMP_COM_FLAG_ = 0;
 303   2              return g_CompValue[index];
 304   2          }
 305   1          else
 306   1          {
 307   2              TemVar1 = g_TempValue[index];      //第一温度
 308   2              TemVar4 = g_CompValue[index];      //第一特征值
 309   2              
 310   2              if(index == 0)
 311   2              {           
 312   3                  TemVar3 = g_TempValue[1];      //索引0的第二温度             
 313   3                  TemVar6 = g_CompValue[1];      //索引0的第二特征值
 314   3                  
 315   3                  TbcValue = TemVar4 + ((Temp-TemVar1)/(TemVar3-TemVar1))*(TemVar6-TemVar4);
 316   3              }
 317   2              else if(index == Temp_LEN)
 318   2              {
 319   3                  TemVar2 = g_TempValue[Temp_LEN-1];    //索引Temp_LEN-1的第二温度     
 320   3                  TemVar5 = g_CompValue[Temp_LEN-1];    //索引Temp_LEN-1的第二特征值
 321   3      
 322   3                  TbcValue = TemVar5 + ((Temp-TemVar2)/(TemVar1-TemVar2))*(TemVar4-TemVar5);
 323   3              }
 324   2              else
 325   2              {
 326   3                  TemVar2 = g_TempValue[index-1];       //索引index-1作为第二温度     
 327   3                  TemVar5 = g_CompValue[index-1];       //索引index-1作为第二特征值
 328   3      
 329   3                
 330   3                  TemVar3 = g_TempValue[index+1];       //索引index+1作为第二温度     
 331   3                  TemVar6 = g_CompValue[index+1];       //索引index+1作为第二特征值
 332   3      
 333   3                  if(_TEMP_INDEX_FLAG_ == 1)  //选择g_TempValue[u1Index+1]作为另外一个计算温度
 334   3                  {
 335   4                      _TEMP_INDEX_FLAG_ = 0;
 336   4                      TbcValue = TemVar4 + ((Temp-TemVar1)/(TemVar3-TemVar1))*(TemVar6-TemVar4);
 337   4                  }
 338   3                  else                        //选择g_TempValue[u1Index-1]作为另外一个计算温度
 339   3                  {
 340   4                      TbcValue = TemVar5 + ((Temp-TemVar2)/(TemVar1-TemVar2))*(TemVar4-TemVar5);
 341   4                  }            
 342   3              }
 343   2              return TbcValue;
 344   2          }
 345   1      }
 346          
 347          
 348          /********************************************************************
 349          Function name:       fCalFreqDrift
 350          Input parameters:
 351              float Temp ：The Temprature of Ambient Enviroment
 352          Return:
 353              float ： The Frequence Drift of Crystal with Temprature
 354          Function:
 355              cal the  Frequence Drift of Crystal with Temprature
 356          Note：
 357                  32.768 KHz Crystals Temperature curve：ppm=0.04*（T-25）^2 
 358          ********************************************************************/
 359          #if 0
              float fCalFreqDrift(float Temp)
              {
                       //return (pow((Temp-25),2)/25.0);
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 7   

                       return(((Temp-25)*(Temp-25))/25.0);
              }
              #endif
 366          
 367          /********************************************************************
 368          Function name:       Comp_Difference_10PPM
 369          Input parameters:
 370              void  
 371          Return:
 372              void
 373          Function:
 374              Compensation difference is or not 10PPM     
 375          ********************************************************************/
 376          void Comp_Difference_10PPM(float value)
 377          {
 378   1              if(fabs(value-_LAST_COM_VALUE_) <= 10.0)
 379   1              {
 380   2                      vScu_SetSysClk32K(); 
 381   2                  vScu_WakeUpTimerWakeUp_1Hour();     //与上次相比，补偿值差值小于等于10ppm,1小时预设值不变
 382   2                  WT_Onehour_Flag = 1;
 383   2                  WT_TenMin_Flag = 0;
 384   2              }
 385   1              else
 386   1              {    
 387   2                      vScu_SetSysClk32K(); 
 388   2                  vScu_WakeUpTimerWakeUp_1Min();     //与上次相比，补偿值差值大于10ppm,预设值变成10分钟
 389   2                  WT_TenMin_Flag = 1;
 390   2                  WT_Onehour_Flag = 0;
 391   2              }  
 392   1      }
 393          
 394          /********************************************************************
 395          Function name:       Real_Tmp
 396          Input parameters:
 397              IC Get Temperature
 398          Return:
 399              Real Temperature
 400          Function:
 401              Get Temperature in air      
 402          ********************************************************************/
 403          
 404          float Real_Tmp(float Tmp)
 405          {
 406   1              UINT8 Index;
 407   1      
 408   1              Index = CompValue_Flag;
 409   1      
 410   1              if(Tmp <= -25.0)
 411   1              {
 412   2                      return (Tmp+g_RealValue[Index][0]);     
 413   2              }
 414   1              else if((Tmp>-25.0) && (Tmp<=10.0))
 415   1              {
 416   2                      return (Tmp+g_RealValue[Index][1]);             
 417   2              }
 418   1              else if((Tmp>10.0) && (Tmp<=20.0))
 419   1              {       
 420   2                      return (Tmp+g_RealValue[Index][2]);     
 421   2              }
 422   1              else if((Tmp>20.0) && (Tmp<=30.0))
 423   1              {
 424   2                      return (Tmp+g_RealValue[Index][3]);     
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 8   

 425   2              }
 426   1              else if((Tmp>30.0) && (Tmp<=50.0))
 427   1              {
 428   2                      return (Tmp+g_RealValue[Index][4]);     
 429   2              }
 430   1              else if((Tmp>50.0) && (Tmp<=67.0))
 431   1              {
 432   2                      return (Tmp+g_RealValue[Index][5]);         
 433   2              }
 434   1              else
 435   1              {
 436   2                      return (Tmp+g_RealValue[Index][6]);         
 437   2              }
 438   1      }
 439          
 440          void IC_Temperature_Test(void)
 441          {
 442   1          float Tmp;
 443   1          float Basic_Tmp;
 444   1              UINT8 Basic_Tmp_Low;
 445   1              UINT16 TmpValue,ADJVAL;
 446   1              
 447   1          //vScu_SetSysClkOsc2M();
 448   1              //vScu_TbcClkEn();
 449   1              vAdcInit(CH_TEMP);
 450   1              //开温度检测使能
 451   1              vAdcTsEn();
 452   1      
 453   1              TmpValue= uiAdc_GetData();              
 454   1              TmpValue= uiAdc_GetData();
 455   1      
 456   1      
 457   1              ADJVAL = _TSADJ_VAL_;
 458   1              //ADJVAL=0x316;
 459   1              Tmp=(((float)ADJVAL-TmpValue)*0.5247);
 460   1              Tmp=30.0+Tmp;   
 461   1              Real_Temp_Value_H = (UINT8)(Tmp);
 462   1              Real_Temp_Value_L = (UINT8)((UINT16)(Tmp*100)%100);
 463   1      
 464   1              if(!Basic_Temp_Cmd)
 465   1              {
 466   2                      Tmp = Tmp-27.5;                         //看当前室温多少，根据不同场景修改基准温度值，目前是26.5度              
 467   2              }
 468   1              else
 469   1              {
 470   2                      Basic_Tmp_Low = (u1)Basic_Temp_Value;
 471   2                      Basic_Tmp = (u1)(Basic_Temp_Value>>8) + ((float)Basic_Tmp_Low/100);
 472   2                      Tmp = Tmp-Basic_Tmp;            //基准温度校准
 473   2              }
 474   1      
 475   1              if(Tmp<-2.0)
 476   1              {
 477   2                      CompValue_Flag = 0x01;
 478   2              }
 479   1              else if(Tmp>=-2.0 && Tmp<-1.0)
 480   1              {
 481   2                      CompValue_Flag = 0x02;          
 482   2              }
 483   1              else if(Tmp>=-1.0 && Tmp<1.0)
 484   1              {
 485   2                      CompValue_Flag = 0x03;  
 486   2              }
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 9   

 487   1              else if(Tmp>=1.0 && Tmp<2.0)
 488   1              {
 489   2                      CompValue_Flag = 0x04;          
 490   2              }
 491   1              else if(Tmp>=2.0 && Tmp<3.0)
 492   1              {       
 493   2                      CompValue_Flag = 0x05;  
 494   2              }
 495   1              else if(Tmp>=3.0 && Tmp<4.0)
 496   1              {
 497   2                      CompValue_Flag = 0x06;  
 498   2              }
 499   1              else if(Tmp>=4.0 && Tmp<5.0)
 500   1              {       
 501   2                      CompValue_Flag = 0x07;  
 502   2              }
 503   1              else if(Tmp>=5.0 && Tmp<6.0)
 504   1              {       
 505   2                      CompValue_Flag = 0x08;  
 506   2              }       
 507   1              else if(Tmp>=6.0 && Tmp<7.0)
 508   1              {
 509   2                      CompValue_Flag = 0x09;   
 510   2              }
 511   1              else
 512   1              {
 513   2                      CompValue_Flag = 0x00;
 514   2                      Exral_Temp_Flag = 1;
 515   2              }
 516   1      
 517   1              //关闭温度检测使能
 518   1              vAdcTsDis();
 519   1      
 520   1              vAdcClose();    
 521   1              
 522   1              //vScu_SetSysClk32K();
 523   1      }
 524          
 525          
 526          /********************************************************************
 527          Function name:       vFreqAdj
 528          Input parameters:
 529              void
 530          Return:
 531              void
 532          Function:
 533              Frequence Adjust
 534          
 535          温度换算：y（mv）=-1.675x（℃）+A
 536                    y=ADC（30℃采样值）*900/1024（mv） 
 537          
 538                            x=30+(_TSADJ_VAL_-ADC_VALUE)*(900/(1024*1.675))
 539                            简化等式：
 540                            x（℃）=30+ (_TSADJ_VAL_-ADC_VALUE)*0.5247  
 541          ********************************************************************/
 542          void vFreqAdj(UINT8 u1Flag)
 543          {
 544   1          float Tmp,Tbc_Value;
 545   1              UINT16 TmpValue,ADJVAL;
 546   1              UINT8 Index;
 547   1      
 548   1          //vScu_SetSysClkOsc2M();
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 10  

 549   1              //vScu_TbcClkEn();
 550   1              vAdcInit(CH_TEMP);
 551   1              //开温度检测使能
 552   1              vAdcTsEn();
 553   1      
 554   1              TmpValue= uiAdc_GetData();      
 555   1              
 556   1              TmpValue= uiAdc_GetData();
 557   1      
 558   1      
 559   1              ADJVAL = _TSADJ_VAL_;
 560   1              //ADJVAL=0x316;
 561   1              Tmp=(((float)ADJVAL-TmpValue)*0.5247);
 562   1              Tmp=30.0+Tmp;
 563   1      
 564   1              #if 0
                      DebugPrintf("Before Comp IC Temperature is:%08.2f\r\n",Tmp);
                      #endif
 567   1      
 568   1              Tmp = Real_Tmp(Tmp);            //芯片所测温度转换到实际温度 
 569   1              
 570   1              Index = vTempValue_Find(Tmp);
 571   1              Tbc_Value = vCompValue_Find(Tmp,Index); 
 572   1      
 573   1              TBCADJL = 0xFF;
 574   1              TBCADJH = 0x7F; 
 575   1      
 576   1              if(Exral_Temp_Flag)
 577   1              {
 578   2                      vTBC_ADJ(Crystal_PPM);
 579   2              }
 580   1              else
 581   1              {
 582   2                      vTBC_ADJ(Tbc_Value+Crystal_PPM);
 583   2              }       
 584   1      
 585   1              //关闭温度检测使能
 586   1              vAdcTsDis();
 587   1      
 588   1              vAdcClose();    
 589   1      
 590   1              //vScu_SetSysClk32K();
 591   1      
 592   1          if(u1Flag)
 593   1          {
 594   2              Comp_Difference_10PPM(Tbc_Value);       //判定当次补偿值与上次的差值是否大于10PPM
 595   2          }   
 596   1      
 597   1          _LAST_COM_VALUE_ = Tbc_Value;               //更新最新温度采样补偿值  
 598   1          
 599   1      }
 600          
 601          
 602          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3260    ----
   CONSTANT SIZE    =    504    ----
   XDATA SIZE       =    112      80
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.01   TBCFUNC                                                               11/23/2016 11:58:14 PAGE 11  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
