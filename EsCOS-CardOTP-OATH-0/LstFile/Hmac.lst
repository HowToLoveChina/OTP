C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE HMAC
OBJECT MODULE PLACED IN .\ObjFile\Hmac.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Func\Hmac.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFile\Fra
                    -me\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PRINT(.
                    -\LstFile\Hmac.lst) OBJECT(.\ObjFile\Hmac.obj)

line level    source

   1          //#include "StdAfx.h"
   2          #include "hmac.h"
   3          #include "sha1.h"
   4          #include "string.h"
   5          #include "OtpFunc.h"
   6          #include "SM4Process.h"
   7          
   8          #if 0
              //////////////////////////////////////////////////////////////////////////
              // 函数功能
              //      计算Sha1值
              // 
              // 函数参数
              //      pu1Out:                 输出参数，哈希结果缓冲区
              //      pu2OutLen:              输出参数，哈希结果长度
              //      pu1In:                  输入参数，参与哈希的数据缓冲区
              //      u4InLen:                输入参数，哈希数据长度
              //      pu1Iv:                  输入参数，参与哈希的数据缓冲区
              //      u2IvLen:                输入参数，哈希数据长度  
              // 返回值
              //      无
              //
              // 备注
              //////////////////////////////////////////////////////////////////////////
              void  HashSha1(u1* pu1Out, u2* pu2OutLen, u1* pu1In, u4 u4InLen, u1* pu1Iv, u2 u2IvLen)
              {
                      sha             blkSHA; 
                      u4              i;
                      
                      sha1_init(&blkSHA);
                      if( NULL != pu1Iv && 0x14 == u2IvLen )
                      {
                              (&blkSHA)->h[0] = BYTE2LONG(pu1Iv);
                              (&blkSHA)->h[1] = BYTE2LONG(pu1Iv+0x04);
                              (&blkSHA)->h[2] = BYTE2LONG(pu1Iv+0x08);
                              (&blkSHA)->h[3] = BYTE2LONG(pu1Iv+0x0C);
                              (&blkSHA)->h[4] = BYTE2LONG(pu1Iv+0x10);
                      }
                      
                      for ( i = 0 ; i < u4InLen; i++ )
                      {
                              if ( 0x00 == (i%0x40) )
                              {
                                      int a;
                                      
                                      a = 0;
                              }
                              sha1_process(&blkSHA, pu1In[i]);
                      }
                      sha1_hash(&blkSHA, (char*)pu1Out);
                      *pu2OutLen = 0x14;
              }
              
C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 2   

              
              //////////////////////////////////////////////////////////////////////////
              // 函数功能
              //      计算Sm3值
              // 
              // 函数参数
              //      pu1Out:                 输出参数，哈希结果缓冲区
              //      pu2OutLen:              输出参数，哈希结果长度
              //      pu1In:                  输入参数，参与哈希的数据缓冲区
              //      u4InLen:                输入参数，哈希数据长度
              //      u1HashAlgId:    输入参数，哈希算法号 C0： MD5， C1：SHA1， C2： SHA256， C3：SHA348， C4：SHA512， C5：SM3
              //
              // 返回值
              //      无
              //
              // 备注
              //////////////////////////////////////////////////////////////////////////
              void HashMsg(u1* pu1Out, u2* pu2OutLen, u1* pu1In, u4 u4InLen, u1 u1HashAlgId)
              {
                      if ( HASH_ALGID_MD5 == u1HashAlgId )
                      {
                              HashMd5(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else if ( HASH_ALGID_SHA1 == u1HashAlgId )
                      {
                              HashSha1(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else if ( HASH_ALGID_SHA256 == u1HashAlgId )
                      {
                              HashSha256(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else if ( HASH_ALGID_SHA384 == u1HashAlgId )
                      {
                              HashSha384(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else if ( HASH_ALGID_SHA512 == u1HashAlgId )
                      {
                              HashSha512(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else if ( HASH_ALGID_SM3 == u1HashAlgId )
                      {
                              HashSm3(pu1Out, pu2OutLen, pu1In, u4InLen, NULL, 0x00);
                      }
                      else
                      {
                              *pu2OutLen = 0x00;
                      }
              }
              #endif
 103          
 104          #if 0
              // 计算HMAC，输出到pbMAC指向的地址
              // 注意：缓冲区长度至少0x14字节
              void HMAC_SHA1(const UINT8* pbKey, UINT32 dwKeyLen, const UINT8* pbMsg, UINT32 dwMsgLen, UINT8* pbMAC)
              {    
                      UINT8 i;
                      sha sh;
                      char hash[20];
                      
                      char K_IPad[BLOCK_LEN] = {0};
                      char K_OPad[BLOCK_LEN] = {0}; 
                      char K[BLOCK_LEN] = {0};        
C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 3   

                      
                      if (dwKeyLen > BLOCK_LEN)
                      {
                              ComputeSHA1(pbKey, dwKeyLen, K);
                      }
                      else
                      {
                              memcpy(K, pbKey, dwKeyLen);
                      }
                      memcpy(K_IPad, K, BLOCK_LEN);
                      memcpy(K_OPad, K, BLOCK_LEN);
                      for (i = 0; i < BLOCK_LEN; i++) // 异或
                      {
                              K_IPad[i] ^= 0x36;
                              K_OPad[i] ^= 0x5C;
                      }
                      
                      sha1_init(&sh);
                      for (i = 0; i < BLOCK_LEN; i++)
                      {
                              sha1_process(&sh, K_IPad[i]);
                      }
                      for (i = 0; i < dwMsgLen; i++)
                      {
                              sha1_process(&sh, pbMsg[i]);
                      }
                      sha1_hash(&sh, hash);
                      
                      sha1_init(&sh);
                      for (i = 0; i < BLOCK_LEN; i++)
                      {
                              sha1_process(&sh, K_OPad[i]);
                      }
                      for (i = 0; i < sizeof(hash); i++)
                      {
                              sha1_process(&sh, hash[i]);
                      }
                      sha1_hash(&sh, hash);
                      
                      memcpy(pbMAC, hash, sizeof(hash));
              }
              #endif
 158          
 159          
 160          // 交行Mini终端计算Hmac的步骤
 161          //      ipad:   填充字节串，内容为：8位字节0x36 重复B次
 162          //      opad:   填充字节串，内容为：8位字节0x5c 重复B次
 163          //      text:   所输入的需要计算MAC的数据，不包括填充字节串
 164          //      K       :       MAC密钥
 165          //      t       :       所得MAC的字节长度
 166          //      B       :       哈希算法分组长度
 167          // 使用如下公式计算输入数据text的MAC值：
 168          //      MAC(text)t = HMAC(K, text)t = HASH((K0opad) || HASH((K0ipad) || text) )
 169          // 具体描述如下：
 170          // 1.   若K = B，令K0 = K。跳转到步骤4；
 171          // 2.   若K > B，令K0 = HASH(K)。跳转到步骤3；
 172          // 3.   若K < B，则在K末尾补字节0x00产生B字节K0；
 173          // 4.   K0与ipad异或产生B字节字符串：K0ipad；
 174          // 5.   将text追加到步骤4得到的字符串K0ipad末尾：(K0ipad)||text；
 175          // 6.   对步骤5得到的字符串进行哈希得到：HASH((K0ipad)||text)；
 176          // 7.   K0与opad异或：K0opad；
 177          // 8.   将步骤6产生的结果追加到步骤7的结果末尾：(K0  opad ) ||HASH((K0  ipad) || text )
C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 4   

 178          // 9.   对步骤8的结果做哈希得到：HASH((K0opad) || HASH((K0  ipad) || text))。
 179          // 10.  步骤9得到的哈希值作为MAC值。
 180          
 181          //////////////////////////////////////////////////////////////////////////
 182          // 函数功能
 183          //      计算Hmac值，使用软算法实现
 184          //
 185          // 函数参数
 186          //      u1HashAlgId:                    输入参数，哈希算法号 C0： MD5， C1：SHA1， C2： SHA256， C3：SHA348， C4：SHA512， C5：S
             -M3
 187          //      pu1MacKey：                             输入参数，Mac密钥缓冲区
 188          //      u2MacKeyLen:                    输入参数，Mac密钥长度
 189          //      pu1Msg：                                输入参数，消息数据缓冲区
 190          //      u4MsgLen:                               输入参数，消息长度
 191          //      pu1OutMac:                              输出参数，Hmac结果的缓冲区
 192          //      pu2OutMacLen:                   输出参数，Hmac结果的长度
 193          //
 194          // 返回值
 195          //      00:                                             成功
 196          //      其它值：                                失败
 197          //
 198          //      备注：
 199          //
 200          //////////////////////////////////////////////////////////////////////////
 201          long HmacEx(u1 u1HashAlgId, u1* pu1MacKey, u2 u2MacKeyLen, u1* pu1Msg, u4 u4MsgLen, u1* pu1OutMac, u2* pu2
             -OutMacLen)
 202          {
 203   1              //long                                  lResult;
 204   1              u1              xdata                           pu1Ipad[0x40] = {0x00};
 205   1              u1              xdata                           pu1Opad[0x40] = {0x00};
 206   1              u1              xdata                           pu1MacKeyBuf[0x40] = {0x00};
 207   1              u2              xdata                           u2Outlen;
 208   1              u1              xdata                           pu1KeyXorIpod[0x40] = {0x00};
 209   1              u1              xdata                           pu1KeyXorOpod[0x80] = {0x00};
 210   1              u1              xdata                           u1BlockLen;
 211   1              u1              xdata                           pu1TempIn[80];
 212   1              u4              xdata                           u4HashLen;
 213   1      
 214   1              //pu1TempIn = NULL;
 215   1              if ( u1HashAlgId < 0xC0 || u1HashAlgId > 0xC5 )
 216   1              {
 217   2                      return -1;
 218   2              }
 219   1              #if 1
 220   1              u1BlockLen = 0x40;
 221   1              //if ( HASH_ALGID_SHA384 == u1HashAlgId || HASH_ALGID_SHA512 == u1HashAlgId )
 222   1              //{
 223   1              //      u1BlockLen = 0x80;
 224   1              //}
 225   1              memset(pu1Ipad, 0x36, u1BlockLen);
 226   1              memset(pu1Opad, 0x5C, u1BlockLen);
 227   1              // 处理Mac密钥，使其结果为B字节
 228   1              if ( u2MacKeyLen > u1BlockLen )
 229   1              {
 230   2                      u2Outlen = sizeof(pu1MacKeyBuf);
 231   2                      //HashMsg(pu1MacKeyBuf, &u2Outlen, pu1MacKey, u2MacKeyLen, u1HashAlgId);
 232   2                      //HashSha1(pu1MacKeyBuf, &u2Outlen, pu1MacKey, u2MacKeyLen, NULL, 0x00);
 233   2                      SHA1Data(pu1MacKeyBuf, pu1MacKey, u2MacKeyLen);
 234   2                      u2MacKeyLen = 0x14;
 235   2              }
 236   1              else
 237   1              {
C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 5   

 238   2                      memcpy(pu1MacKeyBuf, pu1MacKey, u2MacKeyLen);
 239   2              }
 240   1              memset(pu1MacKeyBuf + u2MacKeyLen, 0x00, ((u2)u1BlockLen - u2MacKeyLen));
 241   1              // 4.   K0与ipad异或产生64字节字符串：K0ipad；
 242   1              memcpy(pu1KeyXorIpod, pu1MacKeyBuf, u1BlockLen);
 243   1              memcpy(pu1KeyXorOpod, pu1MacKeyBuf, u1BlockLen);
 244   1              memxor(pu1KeyXorIpod, pu1Ipad, u1BlockLen);
 245   1      
 246   1              // 5.   将text追加到步骤4得到的字符串K0ipad末尾：(K0ipad)||text；
 247   1              //pu1TempIn = (u1*)malloc(u4MsgLen + 0x90);
 248   1              //if ( NULL == pu1TempIn )
 249   1              //{
 250   1              //      lResult = GetLastError();
 251   1              //      return lResult;
 252   1              //}
 253   1              memcpy(pu1TempIn, pu1KeyXorIpod, u1BlockLen);
 254   1              memcpy(pu1TempIn + u1BlockLen, pu1Msg, u4MsgLen);
 255   1              u4HashLen = u4MsgLen + u1BlockLen;
 256   1              //u2Outlen = sizeof(pu1MacKeyBuf);
 257   1              #endif
 258   1              // 6.   对步骤5得到的字符串进行哈希得到：HASH((K0ipad)||text)；
 259   1              //HashMsg(pu1MacKeyBuf, &u2Outlen, pu1TempIn, u4HashLen, u1HashAlgId);
 260   1              //pu1TempIn[0] = 1;
 261   1              //pu1TempIn[1] = 2;
 262   1              //pu1TempIn[2] = 3;
 263   1              //pu1TempIn[3] = 4;
 264   1              //pu1TempIn[4] = 5;
 265   1              //pu1TempIn[5] = 6;
 266   1              //u4HashLen = 6;
 267   1              //while(1);
 268   1              //HashSha1(pu1MacKeyBuf, &u2Outlen, pu1TempIn, u4HashLen, NULL, 0x00);
 269   1              SHA1Data(pu1MacKeyBuf, pu1TempIn, u4HashLen);
 270   1              u2Outlen = 0x14;
 271   1              // 7.   K0与opad异或：K0opad；
 272   1              memxor(pu1KeyXorOpod, pu1Opad, u1BlockLen);
 273   1      
 274   1              // 8.   将步骤6产生的结果追加到步骤7的结果末尾：(K0  opad ) ||HASH((K0  ipad) || text )
 275   1              memcpy(pu1KeyXorOpod + u1BlockLen, pu1MacKeyBuf, u2Outlen);
 276   1              u4HashLen = u1BlockLen + u2Outlen;
 277   1      
 278   1              // 9.   对步骤8的结果做哈希得到：HASH((K0opad) || HASH((K0  ipad) || text))。
 279   1              //u2Outlen = sizeof(pu1MacKeyBuf);
 280   1              //HashMsg(pu1OutMac, &u2Outlen, pu1KeyXorOpod, u4HashLen, u1HashAlgId);
 281   1              //while(1);
 282   1              //HashSha1(pu1OutMac, &u2Outlen, pu1KeyXorOpod, u4HashLen, NULL, 0x00);
 283   1              SHA1Data(pu1OutMac, pu1KeyXorOpod, u4HashLen);
 284   1      
 285   1              // 10.  步骤9得到的哈希值作为MAC值。
 286   1              
 287   1              *pu2OutMacLen = 20;                     //u2Outlen;
 288   1      
 289   1              //if ( NULL != pu1TempIn )
 290   1              //{
 291   1              //      free(pu1TempIn);
 292   1              //}
 293   1              return 0x00;
 294   1      }
 295          
 296          
 297          
 298          

C51 COMPILER V9.01   HMAC                                                                  11/23/2016 11:58:15 PAGE 6   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    668    ----
   CONSTANT SIZE    =    384    ----
   XDATA SIZE       =   ----     490
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
