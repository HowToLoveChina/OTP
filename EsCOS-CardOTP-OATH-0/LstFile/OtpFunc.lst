C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE OTPFUNC
OBJECT MODULE PLACED IN .\ObjFile\OtpFunc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Func\OtpFunc.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFile\
                    -Frame\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PRIN
                    -T(.\LstFile\OtpFunc.lst) OBJECT(.\ObjFile\OtpFunc.obj)

line level    source

   1          /********************************************************************
   2                                    Nationz Co.,Ltd
   3                  Copyright (c) 2009－2015 All Rights Reserved
   4           ********************************************************************
   5          File: OtpFunc.c
   6          History：
   7          Version                      Author                     Date
   8          V0.1                         nationz                  2013-04-2
   9          
  10          Description:
  11               OtpFunc Source Code File;
  12          Function list:
  13              UINT8 ucOtpByteRead(UINT16 Addr);
  14              void vOtpRead(UINT16 Addr,UINT16 Len,UINT8  *DataBuf);
  15                      
  16          Special statement:
  17               NULL
  18           *******************************************************************/
  19          #define _OTPFUNC_C_
  20          #include "OTPFUNC.H"
  21          #include "OTPFRAME.H"
  22          #include "LCDFUNC.H"
  23          #include "SCUFUNC.H"
  24          #include "string.H"     
  25          #include "SM3FUNC.H"
  26          #include "SM4.h"
  27          #include "SM4Process.h"
  28          #include "UARTFRAME.h"
  29          #include "TbcFunc.h"
  30          //#include "SM3.h"
  31          #include "Typedefine.h"
  32          #include "Sha1.h"
  33          #include "Hmac.h"
  34          
  35          u1 idata g_u1RandCnt _at_ 0x39;
  36          u1 g_pu1Random[CHAL_LEN];
  37          u1 g_u1OtpInput[80];
  38          /********************************************************************
  39          Function name:       UINT8 ucOtpByteRead(UINT16 Addr)
  40          Input parameters:
  41              UINT16 Addr： read Address  
  42                   
  43          Return:
  44              UINT8:return data of the address
  45          Function:
  46              read one byte from the specify address 
  47          ********************************************************************/
  48          #if 0
              UINT8 ucOtpByteRead(UINT16 Addr)
              {
                      UINT8 DataValue;
                      UINT8 code *pAddr;
                      pAddr =(UINT8 code *) Addr;     
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 2   

                      DataValue = *pAddr;     
                      return DataValue;
              }
              #endif
  58          /********************************************************************
  59          Function name:       void vOtpRead(UINT16 Addr,UINT16 Len,UINT8  *DataBuf)
  60          Input parameters:
  61              UINT16 Addr：read Address
  62                  UINT16 Len:      length of data to read
  63                  UINT8  *DataBuf: save the data read from the address
  64                   
  65          Return:
  66              void
  67          Function:
  68              read  data from the specify address
  69          ********************************************************************/
  70          #if 0
              void vOtpRead(UINT16 Addr,UINT16 Len,UINT8  *DataBuf)
              {
                      UINT16 i;
                      UINT8 code *pAddr;
                      pAddr = (UINT8 code *)Addr;
                      for(i=0;i<Len;i++)
                      {
                              *DataBuf++=*pAddr++;
                      }
              }
              #endif
  82          /********************************************************************
  83          Function name:      void vOtpRead_ChipSn(UINT8  *DataBuf)
  84          Input parameters:     
  85                  UINT8  *DataBuf: save the data read from the address
  86                   
  87          Return:
  88              void
  89          Function:
  90              read the Chip SN 
  91          ********************************************************************/
  92          
  93          #if 0
              void vOtpRead_ChipSn(UINT8  *DataBuf)
              {
                      UINT16 i;
                      UINT8 code *pAddr;
              
              #ifdef  _CODE_16K_
                      pAddr = (UINT8 code *)(0X3FE0);
              #endif
              
              #ifdef  _CODE_24K_
                      pAddr = (UINT8 code *)(0X5FE0);
              #endif
              
              #ifdef  _CODE_48K_
                      pAddr = (UINT8 code *)(0XBFE0);
              #endif
              
                      for(i=0;i<16;i++)
                      {
                              *DataBuf++=*pAddr++;
                      }
              }
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 3   

              #endif
 117          
 118          #if 0
              u1 PinPowerCheck(u1 *pu1DataBuf)
              {
                              
                      if((pu1DataBuf[0]==pu1DataBuf[1]))                                              // 111111  123456  112233  654321  332211都不可用
                      {
                              if((pu1DataBuf[0]==pu1DataBuf[2]))
                              {
                                      if((pu1DataBuf[0]==pu1DataBuf[3])&&(pu1DataBuf[0]==pu1DataBuf[4])&&(pu1DataBuf[0]==pu1DataBuf[5]))
                                      {
                                              //while(1);
                                              return 1;
                                      }
                              }
                              else if((pu1DataBuf[0]>pu1DataBuf[2]))
                              {
                                      if((pu1DataBuf[0]-pu1DataBuf[2])==1)
                                      {
                                              if((pu1DataBuf[2]==pu1DataBuf[3]))
                                              {
                                                      if((pu1DataBuf[2]>pu1DataBuf[4])&&((pu1DataBuf[2]-pu1DataBuf[4])==1))
                                                      {
                                                              if((pu1DataBuf[4]==pu1DataBuf[5]))
                                                              {
                                                                      return 1;
                                                              }
                                                      }
                                              }
                                      }
                              }
                              else
                              {
                                      if((pu1DataBuf[2]-pu1DataBuf[0])==1)
                                      {
                                              if((pu1DataBuf[2]==pu1DataBuf[3]))
                                              {
                                                      if((pu1DataBuf[4]>pu1DataBuf[2])&&((pu1DataBuf[4]-pu1DataBuf[2])==1))
                                                      {
                                                              if((pu1DataBuf[4]==pu1DataBuf[5]))
                                                              {
                                                                      return 1;
                                                              }
                                                      }
                                              }
                                      }
                              }
                      }
                      #if 1
                      else if(pu1DataBuf[0]>pu1DataBuf[1])
                      {
                              if((pu1DataBuf[0]-pu1DataBuf[1])==1)
                              {
                                      if((pu1DataBuf[1]>pu1DataBuf[2])&&((pu1DataBuf[1]-pu1DataBuf[2])==1))
                                      {
                                              if((pu1DataBuf[2]>pu1DataBuf[3])&&((pu1DataBuf[2]-pu1DataBuf[3])==1))
                                              {
                                                      if((pu1DataBuf[3]>pu1DataBuf[4])&&((pu1DataBuf[3]-pu1DataBuf[4])==1))
                                                      {
                                                              if((pu1DataBuf[4]>pu1DataBuf[5])&&((pu1DataBuf[4]-pu1DataBuf[5])==1))
                                                              {
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 4   

                                                                      return 1;
                                                              }
                                                      }
                                              }
                                      }
                              }
                      }
                      else
                      {
                              if((pu1DataBuf[1]-pu1DataBuf[0])==1)
                              {
                                      if((pu1DataBuf[1]<pu1DataBuf[2])&&((pu1DataBuf[2]-pu1DataBuf[1])==1))
                                      {
                                              if((pu1DataBuf[2]<pu1DataBuf[3])&&((pu1DataBuf[3]-pu1DataBuf[2])==1))
                                              {
                                                      if((pu1DataBuf[3]<pu1DataBuf[4])&&((pu1DataBuf[4]-pu1DataBuf[3])==1))
                                                      {
                                                              if((pu1DataBuf[4]<pu1DataBuf[5])&&((pu1DataBuf[5]-pu1DataBuf[4])==1))
                                                              {
                                                                      return 1;
                                                              }
                                                      }
                                              }
                                      }
                              }
                      }
                      #endif
                      return 0;
              
              
              }
              #endif
 210          
 211          void GetTimeFactor(u1 *pu1Time)
 212          {
 213   1              u4 u4Minite;
 214   1              //u2 u2time;
 215   1      
 216   1              //u4Minite = (gTimer_Count_Base + TBC_COUNT_VALUE)/60;
 217   1              u4Minite = (gTimer_Count_Base + Base_Time())/TIMESTEP;          //60
 218   1      
 219   1              #if(GMT)
                      u2time = 8*60*60/TIMESTEP;
                      u4Minite -= u2time;
                      #endif
 223   1              
 224   1              gToken_Time1 = u4Minite;
 225   1              
 226   1              memset(pu1Time, 0x00, 8);
 227   1              pu1Time[0x07] = (u1)u4Minite;
 228   1              u4Minite >>= 0x08;
 229   1              pu1Time[0x06] = (u1)u4Minite;
 230   1              u4Minite >>= 0x08;
 231   1              pu1Time[0x05] = (u1)u4Minite;
 232   1              u4Minite >>= 0x08;
 233   1              pu1Time[0x04] = (u1)u4Minite;
 234   1              u4Minite >>= 0x08;
 235   1      }
 236          
 237          #if 0
              // 把pu1Input转换成可显示的数字
              // 每个字节转成2字节到4字节, 每个半字节,如果小于0x0A, 转成1字节, 如果大于0x09, 转成2字节
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 5   

              // 另外, 优先地, 如果第一个半字节就大于9, 直接把一个字节转换成3字节, 如0xFF转成255(0x32, 0x35, 0x35)
              // 我们只是用来做HASH计算
              void Byte2Num(u1* pu1OutPut, u2 u2OutPutLen, const u1* pu1Input, u1 u1InputLen)
              {
                      u1 u1Tmp;
                      u1 u1Tmp2;
                      u1 u1For;
                      u2 u2Index;
                      
                      u2Index= 0x00;
                      for ( u1For=0x00; u1For<u1InputLen; u1For++ )
                      {
                              u1Tmp = (pu1Input[u1For]>>0x04);
                              if ( u1Tmp < 0x0A )
                              {
                                      pu1OutPut[u2Index++] = 0x30 + u1Tmp;
                              }
                              else
                              {
                                      // 第一个半字节>9, 把整个字节转换成3字节
                                      u1Tmp2 = pu1Input[u1For];
                                      pu1OutPut[u2Index++] = 0x30 + u1Tmp2/100;
                                      if ( u2Index == u2OutPutLen )
                                      {
                                              return;
                                      }
                                      u1Tmp = u1Tmp2/10;
                                      pu1OutPut[u2Index++] = 0x30 + u1Tmp%10;
                                      if ( u2Index == u2OutPutLen )
                                      {
                                              return;
                                      }
                                      pu1OutPut[u2Index++] = 0x30 + u1Tmp2%10;
                                      if ( u2Index == u2OutPutLen )
                                      {
                                              return;
                                      }
                                      continue;
                              }
                              if ( u2Index == u2OutPutLen )
                              {
                                      return;
                              }
                              u1Tmp = (pu1Input[u1For]&0x0F);
                              if ( u1Tmp < 0x0A )
                              {
                                      pu1OutPut[u2Index++] = 0x30 + u1Tmp;
                              }
                              else
                              {
                                      pu1OutPut[u2Index++] = 0x30 + (u1Tmp - 0x09);
                                      if ( u2Index == u2OutPutLen )
                                      {
                                              return;
                                      }
                                      pu1OutPut[u2Index++] = 0x30 + 0x09;
                              }
                              if ( u2Index == u2OutPutLen )
                              {
                                      return;
                              }
                      }
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 6   

              }
              #endif
 304          
 305          ///////////////////////////////////////////////////
 306          // 功能：从HMAC码中得到指定长度的密码, 国密标准
 307          // szOTP:               输出参数：OTP
 308          // dwHOTPLen：  输入参数，指定的密码的长度
 309          // pbMAC:               输入参数，HMAC码
 310          // dwMACLen：   输入参数，pbMAC的长度，要求为
 311          // 返回值：             参数错误:FALSE。成功：TRUE
 312          ///////////////////////////////////////////////////
 313          /*
 314          void SubstractHotp(u1* pszOtp, u1 u1OTPLen, u1* pu1MAC, u1 u1MACLen)
 315          {
 316                  u1                              i;
 317                  u4      xdata           u4Mode;
 318                  u4      xdata           u4S1,u4S2,u4S3,u4S4,u4S5,u4S6,u4S7,u4S8;
 319                  u4      xdata           u4S;
 320                  u4      xdata           u4OD;
 321                  u4      xdata           u4Index;
 322                  u4      xdata           u4Tmp1,u4Tmp2,u4Tmp3,u4Tmp4;
 323                  
 324                  if ( 0x20 != u1MACLen )
 325                  {
 326                          return;
 327                  }
 328          
 329                  u4Tmp1 = ((u4)(pu1MAC[0x00])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x01])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x02])<<0
             -x08); u4Tmp4 = pu1MAC[0x03]; 
 330                  u4S1 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 331                  u4Tmp1 = ((u4)(pu1MAC[0x04])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x05])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x06])<<0
             -x08); u4Tmp4 = pu1MAC[0x07];
 332                  u4S2 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 333                  u4Tmp1 = ((u4)(pu1MAC[0x08])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x09])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x0A])<<0
             -x08); u4Tmp4 = pu1MAC[0x0B];
 334                  u4S3 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 335                  u4Tmp1 = ((u4)(pu1MAC[0x0C])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x0D])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x0E])<<0
             -x08); u4Tmp4 = pu1MAC[0x0F];
 336                  u4S4 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 337                  u4Tmp1 = ((u4)(pu1MAC[0x10])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x11])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x12])<<0
             -x08); u4Tmp4 = pu1MAC[0x13];
 338                  u4S5 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 339                  u4Tmp1 = ((u4)(pu1MAC[0x14])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x15])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x16])<<0
             -x08); u4Tmp4 = pu1MAC[0x17];
 340                  u4S6 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 341                  u4Tmp1 = ((u4)(pu1MAC[0x18])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x19])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x1A])<<0
             -x08); u4Tmp4 = pu1MAC[0x1B];
 342                  u4S7 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 343                  u4Tmp1 = ((u4)(pu1MAC[0x1C])<<0x18); u4Tmp2 = ((u4)(pu1MAC[0x1D])<<0x10); u4Tmp3 = ((u4)(pu1MAC[0x1E])<<0
             -x08); u4Tmp4 = pu1MAC[0x1F];
 344                  u4S8 = u4Tmp1 | u4Tmp2 | u4Tmp3 | u4Tmp4;
 345          
 346          
 347                  u4S = u4S1;
 348                  u4S += u4S2;
 349                  u4S += u4S3;
 350                  u4S += u4S4;
 351                  u4S += u4S5;
 352                  u4S += u4S6;
 353                  u4S += u4S7;
 354                  u4S += u4S8;
 355                  u4OD = u4S;
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 7   

 356                  
 357                  u4Mode = 1;
 358                  for ( i = 1; i <= u1OTPLen; i++)
 359                  {
 360                          u4Mode *= 10;
 361                  }
 362                  u4OD %= u4Mode;
 363          
 364                  for ( i = 0; i < u1OTPLen; i++)
 365                  {
 366                          pszOtp[i] = '0';
 367                  }
 368                  pszOtp += (u1OTPLen - 0x01);
 369                  u4Mode = 10;
 370                  while ( u1OTPLen )
 371                  {
 372                          u4Index = (u4OD%u4Mode);
 373                          u4OD -= u4Index;
 374                          u4Index /= (u4Mode/10);
 375                          u4Mode *= 10;
 376                          *pszOtp = 0x30 + (u1)u4Index;
 377                          u1OTPLen--;
 378                          pszOtp--;
 379                  }
 380          }
 381          */
 382          
 383          ///////////////////////////////////////////////////
 384          // 功能：从HMAC码中得到指定长度的密码
 385          // pbMAC:               输入参数，HMAC码
 386          // dwMACLen：   输入参数，pbMAC的长度，要求为
 387          // dwHOTPLen：  输入参数，指定的密码的长度
 388          // szOTP:               输出参数：OTP
 389          // 返回值：             参数错误:FALSE。成功：TRUE
 390          ///////////////////////////////////////////////////
 391          BOOL ExtractHOTP(UINT8* pu1MAC, UINT32 dwMACLen, UINT8* pszOtp, UINT32 dwOTPLen)
 392          {
 393   1              UINT8       i;
 394   1              UINT32          dwData;
 395   1              UINT8           index;
 396   1              //UINT32            dwMode;
 397   1              //UINT32                nLen;
 398   1              UINT32  u4Mode;
 399   1              UINT32   u4Index;
 400   1              //UINT8         szTemp[OTP_MAX_LEN+1];
 401   1      
 402   1              if ( dwMACLen != OTP_HASH_LEN_SHA1)
 403   1              {
 404   2                      return FALSE;
 405   2              }
 406   1              if ( dwOTPLen < OTP_MIN_LEN )
 407   1              {
 408   2                      dwOTPLen = OTP_MIN_LEN;
 409   2              }
 410   1              if ( dwOTPLen > OTP_MAX_LEN)
 411   1              {
 412   2                      dwOTPLen = OTP_MAX_LEN;
 413   2              }
 414   1      //      BYTE pbMAC[32] = {128,233,57,17,153,230,80,173,84,74,244,57,140,69,150,13,172,170,113,121,83,205,51,19
             -2,191,147,233,228,103,217,69,225};
 415   1      //      dwMACLen = 32;
 416   1      //      dwOTPLen = 8;
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 8   

 417   1              index = pu1MAC[dwMACLen-1];
 418   1              index &= 0x0F;
 419   1              
 420   1              dwData = pu1MAC[index];
 421   1              dwData &= 0x7F;
 422   1              dwData <<= 0x08;
 423   1              dwData |= pu1MAC[index+1];
 424   1              dwData <<= 0x08;
 425   1              dwData |= pu1MAC[index+2];
 426   1              dwData <<= 0x08;
 427   1              dwData |= pu1MAC[index+3];
 428   1      
 429   1              #if 0
                      dwMode = 1;
                      for ( i = 1; i <= dwOTPLen; i++)
                      {
                              dwMode *= 10;
                      }
                      dwData %= dwMode;
              
                      for ( i = 0; i < dwOTPLen; i++)
                      {
                              pszOtp[i] = '0';
                      }
                      
                      //nLen = strlen(szTemp);
                      //memcpy(&pszOtp[dwOTPLen-nLen], szTemp, nLen+1);
                      #endif
 445   1              u4Mode = 1;
 446   1              for ( i = 1; i <= dwOTPLen; i++)
 447   1              {
 448   2                      u4Mode *= 10;
 449   2              }
 450   1              dwData %= u4Mode;
 451   1      
 452   1              for ( i = 0; i < dwOTPLen; i++)
 453   1              {
 454   2                      pszOtp[i] = '0';
 455   2              }
 456   1              pszOtp += (dwOTPLen - 0x01);
 457   1              u4Mode = 10;
 458   1              while ( dwOTPLen )
 459   1              {
 460   2                      u4Index = (dwData%u4Mode);
 461   2                      dwData -= u4Index;
 462   2                      u4Index /= (u4Mode/10);
 463   2                      u4Mode *= 10;
 464   2                      *pszOtp = 0x30 + (u1)u4Index;
 465   2                      dwOTPLen--;
 466   2                      pszOtp--;
 467   2              }
 468   1      
 469   1              return TRUE;
 470   1      }
 471          
 472          ///////////////////////////////////////////////////
 473          // 功能：Otp计算动态口令
 474          // pu1Time:                     输入参数：时间因子[8]
 475          // u1TimeLen            输入参数，时间因子长度，目前为8字节
 476          // pu1Seed:                     输入参数：Otp种子，64字节随机数的SM3值
 477          // u1SeedSize           输入参数，Otp种子长度，目前为32字节
 478          // pu1Question:         输入参数：挑战码，如果是计算激活阶段的认证码，这里是Otp序列号后6位，例如303030303031
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 9   

 479          // u1QuestionLen:       输入参数，挑战码长度
 480          // pu1Ocra:                     输出参数，动态口令
 481          // pu1OcraLen:          输出参数，动态口令的长度，目前为8字节
 482          // 返回值：                     0成功，否则失败
 483          ///////////////////////////////////////////////////
 484          
 485          //这里可能需要将字符串转换成十六进制数
 486          u1 GenOtpOcra(u1* pu1Time,u1 u1TimeLen,u1* pu1Seed,u1 u1SeedSize,u1* pu1Question,u1 u1QuestionLen,u1* pu1O
             -cra,u1* pu1OcraLen )
 487          {
 488   1              u1 u1Tmp;
 489   1              u1 *pu1Tmp; //seed 20bytes + time 8bytes + 挑战口令最大22bytes = 50
 490   1              //u1 u1SM3HashOutput[32];               //该芯片hash 的输入和输出不能是同一个数组
 491   1              //u2 out[32];
 492   1      
 493   1              //u1 u1Hmac_Sha1Output[20];             //该芯片hash 的输入和输出不能是同一个数组
 494   1              u1 out[20];
 495   1              u2 u2Len;
 496   1              
 497   1              memset(out,0x00,20);
 498   1      
 499   1              pu1Tmp = g_u1OtpInput; //T8的stack不够，故用全局变量RAM来保存
 500   1              if ( 0x08 != u1TimeLen )
 501   1              {
 502   2                      return 0xFF;
 503   2              }                       
 504   1                      
 505   1          if ( u1QuestionLen < 0x08 )
 506   1          {
 507   2              memset(pu1Question + u1QuestionLen, 0x00, 0x08 - u1QuestionLen);
 508   2              u1QuestionLen = 0x08;
 509   2          }
 510   1              
 511   1              u1Tmp = 0;
 512   1              /*
 513   1              memcpy(pu1Tmp + u1Tmp, pu1Seed, u1SeedSize);
 514   1              u1Tmp += u1SeedSize;
 515   1              */
 516   1              memcpy(pu1Tmp + u1Tmp, pu1Time, u1TimeLen);
 517   1              u1Tmp += u1TimeLen;
 518   1              //memcpy(pu1Tmp + u1Tmp, pu1Question, u1QuestionLen);                   //test20160718
 519   1              //u1Tmp += u1QuestionLen;       
 520   1      
 521   1              
 522   1              //u1Tmp = SM3_Hash(pu1Tmp, u1Tmp, out); 
 523   1              //HMAC_SHA1(pu1Seed, u1SeedSize, pu1Tmp, u1Tmp, out);
 524   1              
 525   1              HmacEx(0xc1, pu1Seed, u1SeedSize, pu1Tmp, u1Tmp, out, &u2Len);          //test
 526   1              //while(1);
 527   1              //memcpy(u1Hmac_Sha1Output,out,20);
 528   1              
 529   1              u1Tmp= 20;
 530   1              // //将数据做转换
 531   1              *pu1OcraLen = 8;
 532   1              //SubstractHotp(pu1Ocra, *pu1OcraLen, u1SM3HashOutput, u1Tmp);  //这里需要修改
 533   1              ExtractHOTP(out, u1Tmp, pu1Ocra, *pu1OcraLen);
 534   1      
 535   1              return 0;
 536   1      }
 537          
 538          // 窗口时间计算
 539          // u1CalFlg: 双数是加, 单数是减
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 10  

 540          void CalTime(u4 *pu4OutTime1, u4 *pu4OutTime2, u4 u4Time1, u4 u4Time2, u1 u1CalFlg)
 541          {
 542   1              if ( 0x01&u1CalFlg )
 543   1              {
 544   2                      if ( 0x00 == u4Time2 )
 545   2                      {
 546   3                              u4Time1 -= 0x01;
 547   3                              u4Time2 = 0xFFFFFFFF;
 548   3                      }
 549   2                      else
 550   2                      {
 551   3                              u4Time2 -= 0x01;
 552   3                      }
 553   2              }
 554   1              else
 555   1              {
 556   2                      if ( 0xFFFFFFFF == u4Time2 )
 557   2                      {
 558   3                              u4Time1 += 0x01;
 559   3                              u4Time2 = 0x00;
 560   3                      }
 561   2                      else
 562   2                      {
 563   3                              u4Time2 += 0x01;
 564   3                      }
 565   2              }
 566   1              *pu4OutTime1 = u4Time1;
 567   1              *pu4OutTime2 = u4Time2;
 568   1              
 569   1      }
 570          long BYTE2LONG(u1* pu1Data)
 571          {
 572   1              long    lResult;
 573   1                      
 574   1              lResult = *(long*)pu1Data;
 575   1              return lResult;
 576   1      }
 577          
 578          #define LONG2BYTE(pu1Data,u4Data)       ((u1*)(pu1Data))[0] = (u1)((u4Data)>>24);((u1*)(pu1Data))[1] = (u1)((u4D
             -ata)>>16);((u1*)pu1Data)[2] = (u1)((u4Data)>>8);((u1*)pu1Data)[3] = (u1)((u4Data))
 579          
 580          //////////////////////////////////////////////////////////////////////////
 581          // 函数功能:
 582          //      验证激活码
 583          // 参数说明:
 584          // pu1Time:                     输入参数：时间因子[8]
 585          // u1TimeLen            输入参数，时间因子长度，目前为8字节
 586          // pu1Seed:                     输入参数：Otp种子，64字节随机数的SM3值
 587          // u1SeedSize           输入参数，Otp种子长度，目前为32字节
 588          // pu1Question:         输入参数：挑战码
 589          // u1QuestionLen:       输入参数，挑战码长度
 590          // pu1Ocra:                     输出参数，动态口令
 591          // pu1OcraLen:          输出参数，动态口令的长度
 592          //  u1Window:       输入参数，校验窗口, 00-小窗口, 01-中窗口, 02-大窗口
 593          // 返回值:
 594          //      0xFF:                   认证失败
 595          //      其它:                   认证成功, 窗口偏移
 596          //////////////////////////////////////////////////////////////////////////
 597          u1 OtpActiveVerify(u1* pu1Time,u1 u1TimeLen,u1* pu1Seed,u1 u1SeedSize,u1* pu1Question,u1 u1QuestionLen,u1*
             - pu1Ocra,u1 u1OcraLen, u1 u1Window )
 598          {
 599   1              u1                      pu1InputOTP[0x08];
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 11  

 600   1              u1                      *pu1T;
 601   1              u1                      pu1Substract[0x20];
 602   1              u4                      u4Time1;
 603   1              u4                      u4Time2;
 604   1              u4                      u4Time1_Dec;
 605   1              u4                      u4Time2_Dec;
 606   1              u4                      u4Time1_Add;
 607   1              u4                      u4Time2_Add;
 608   1              u1                      u1Index;
 609   1              u1                      u1Tmp;
 610   1              u1                      u1OtpDataLen;
 611   1              u1                      u1NumAdd;
 612   1              u1                      u1NumDec;
 613   1              //u1                    *pu1OtpData;//[0x80];
 614   1              u1                      pu1OtpTmp[0x20];
 615   1              u1                      out[32];
 616   1              u2                      u2Len;
 617   1      
 618   1              //pu1OtpData =g_u1OtpInput;
 619   1              // 设置好各个参数的值
 620   1              memset(g_u1OtpInput, 0x00, 80);
 621   1              /*
 622   1              memcpy(g_u1OtpInput, pu1Seed, u1SeedSize);  // SEED
 623   1              memxor(g_u1OtpInput, NULL, 0x10);                               //OTP激活阶段，种子运算前需要SEED前半部份取反
 624   1              u1OtpDataLen = u1SeedSize;
 625   1              */
 626   1              u1OtpDataLen = 0;
 627   1              memcpy(g_u1OtpInput+u1OtpDataLen, pu1Time, u1TimeLen);  // T
 628   1              pu1T = g_u1OtpInput+u1OtpDataLen;
 629   1              u1OtpDataLen += u1TimeLen;
 630   1              memcpy(g_u1OtpInput+u1OtpDataLen, pu1Question, u1QuestionLen);  // Q
 631   1              u1OtpDataLen += u1QuestionLen;
 632   1              memcpy(pu1InputOTP, pu1Ocra, u1OcraLen);
 633   1      
 634   1              // 先测试当前时间
 635   1              u4Time1_Dec = BYTE2LONG(pu1T);
 636   1              u4Time2_Dec = BYTE2LONG((pu1T + 0x04));
 637   1              //u4Time1_Dec = BYTE2LONG(pu1Time);
 638   1              //u4Time2_Dec = BYTE2LONG((pu1Time + 0x04));
 639   1              u4Time1_Add = u4Time1_Dec;
 640   1              u4Time2_Add = u4Time2_Dec;
 641   1      
 642   1              if ( OTP_SMALL_WINDOW == u1Window )
 643   1              {
 644   2                      // 小窗口
 645   2                      // 前1后1
 646   2                      u1Window = 0x03;
 647   2              }
 648   1              else if ( OTP_MIDDLE_WINDOW == u1Window  )
 649   1              {
 650   2                      // 中窗口
 651   2                      // 前4后4
 652   2                      u1Window = 0x09;
 653   2              }
 654   1              else
 655   1              {
 656   2                      // 大窗口
 657   2                      // 前8后8
 658   2                      u1Window = 0x11;
 659   2      
 660   2              }
 661   1              u1NumAdd = 0x00;
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 12  

 662   1              u1NumDec = 0x80;
 663   1              for ( u1Index = 0x00; u1Index < u1Window; u1Index++ )
 664   1              {
 665   2                      if ( 0x00 == u1Index )
 666   2                      {
 667   3                              // 当前时间
 668   3                              u4Time1 = u4Time1_Dec;
 669   3                              u4Time2 = u4Time2_Dec;
 670   3                      }
 671   2                      else if ( 0x01 & u1Index )
 672   2                      {
 673   3                              CalTime(&u4Time1, &u4Time2, u4Time1_Dec, u4Time2_Dec, u1Index);
 674   3                              u4Time1_Dec = u4Time1;
 675   3                              u4Time2_Dec = u4Time2;
 676   3                              u1NumDec++;
 677   3                      }
 678   2                      else
 679   2                      {
 680   3                              CalTime(&u4Time1, &u4Time2, u4Time1_Add, u4Time2_Add, u1Index);
 681   3                              u4Time1_Add = u4Time1;
 682   3                              u4Time2_Add = u4Time2;
 683   3                              u1NumAdd++;
 684   3                      }
 685   2      
 686   2                      LONG2BYTE(pu1T, u4Time1);
 687   2                      LONG2BYTE((pu1T + 0x04), u4Time2);
 688   2                      //LONG2BYTE(pu1Time, u4Time1);
 689   2                      //LONG2BYTE((pu1Time + 0x04), u4Time2);
 690   2                      //memcpy(g_u1OtpInput+u1OtpDataLen, pu1Time, u1TimeLen);  
 691   2      
 692   2                      //u1Tmp = SM3_Hash(g_u1OtpInput,u1OtpDataLen,out);              
 693   2                      //HMAC_SHA1(pu1Seed, u1SeedSize, g_u1OtpInput, u1OtpDataLen, out);
 694   2                      HmacEx(0xc1, pu1Seed, u1SeedSize, g_u1OtpInput, u1OtpDataLen, out, &u2Len);             //test
 695   2                      memcpy(pu1OtpTmp,out,20);
 696   2      
 697   2                      
 698   2                      u1Tmp = 20;     //text
 699   2                      //SubstractHotp(pu1Substract, u1OcraLen, pu1OtpTmp, u1Tmp); //这里需要修改
 700   2                      ExtractHOTP(pu1OtpTmp, u1Tmp, pu1Substract, u1OcraLen);
 701   2                      
 702   2                      if ( 0x00 == memcmp(pu1Substract, pu1InputOTP, u1OcraLen) )
 703   2                      {
 704   3                              if ( 0x00 == u1Index )
 705   3                              {
 706   4                                      return 0x00;
 707   4                              }
 708   3                              else if ( 0x01 & u1Index )
 709   3                              {
 710   4                                      return u1NumDec;
 711   4                              }
 712   3                              else
 713   3                              {
 714   4                                      return u1NumAdd;
 715   4                              }
 716   3                      }
 717   2              }
 718   1              return 0xFF;
 719   1      }
 720          
 721          u1 CosOperation(u1 Mode,u1 *pu1DataBuf)
 722          {
 723   1              //u1 u1Len;
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 13  

 724   1              u1 u1Status;
 725   1              //u1 u1ChalLen;
 726   1              u1 u1Rsp;
 727   1              u1 pu1MacKey[16];
 728   1              //u1 pu1Q[6];
 729   1              u1 pu1Seed[SEED_LEN];
 730   1          u1 i;
 731   1              //u1 j;
 732   1              u1 u1OLen;
 733   1              u1 pu1TimeFactor[8];
 734   1              //u1 pu1Buff[9];
 735   1              u1 pu1IV[16];
 736   1              u2 u2Len;
 737   1      
 738   1              //u1 out[36];
 739   1              
 740   1      
 741   1              vScu_SetSysClkOsc2M();
 742   1          switch( Mode )
 743   1              {
 744   2                      case OP_SN:
 745   2                              {
 746   3                                      memset(g_u1SN,0x00,g_SNLen);
 747   3                                      memcpy(g_u1SN,pu1DataBuf,g_SNLen);
 748   3                                      memcpy(g_u1Key,pu1DataBuf+g_SNLen+TIME_LEN,KEY_LEN);
 749   3                                      
 750   3                                      for(i=0;i<KEY_LEN;i++) pu1MacKey[i] =g_u1PriKey[i];
 751   3                                      //u2Len =KEY_LEN;
 752   3                                      SM4_Init(pu1MacKey);
 753   3                                      SM4_Crypto(g_u1Key,KEY_LEN,0x01,0x00,NULL,g_u1Key);             //解密 u1Key
 754   3                                      u1Rsp = OTPSECU_OP_OK;
 755   3                                      break;
 756   3                              }
 757   2                      case OP_MACKEY_SEEDKEY:
 758   2                              {
 759   3                              
 760   3                                      memset(g_u1MacKey,0x00,MACKEY_LEN);
 761   3                                      //memset(g_u1SeedKey,0x00,SEEDKEY_LEN);
 762   3                                      memset(pu1Seed,0x00, SEED_LEN);
 763   3                                      memcpy(g_u1MacKey,pu1DataBuf,MACKEY_LEN);
 764   3                                      //memcpy(g_u1SeedKey,pu1DataBuf+MACKEY_LEN,SEEDKEY_LEN);
 765   3                                      memcpy(pu1Seed,pu1DataBuf+MACKEY_LEN,20);
 766   3                                      for(i=0;i<KEY_LEN;i++) pu1MacKey[i] =g_u1Key[i];
 767   3                                      //u2Len =MACKEY_LEN;
 768   3                                      SM4_Init(pu1MacKey);
 769   3                                      SM4_Crypto(g_u1MacKey,MACKEY_LEN,0x01,0x00,NULL,g_u1MacKey);            //解密 mac_Key
 770   3                                      //u2Len =SEEDKEY_LEN;
 771   3                                      
 772   3                                      //for(i=0;i<KEY_LEN;i++) pu1MacKey[i] =g_u1Key[i];
 773   3                                      //SM4_Init(pu1MacKey);
 774   3                                      //SM4_Crypto(g_u1SeedKey,MACKEY_LEN,0x01,0x00,NULL,g_u1SeedKey);                //解密 seed_Key
 775   3      
 776   3                                      u2Len = 32;
 777   3                                      for(i=0;i<16;i++) pu1MacKey[i] = g_u1Key[i];
 778   3                                      SM4_Init(pu1MacKey);
 779   3                                      SM4_Crypto(pu1Seed,u2Len,0x00,0x00,NULL,gUserInfo);             //jia mi seed
 780   3                                      
 781   3                                      g_AutoUnlockCnt = 0;
 782   3                                      gPinErr_Count = 0;
 783   3                                      gUnlockPinErr_Count = 0;
 784   3                                      gPinErr_Time = 0;
 785   3                                      u1Rsp = OTPSECU_OP_OK;
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 14  

 786   3                                      memset(pu1Seed,0x00,SEED_LEN);
 787   3                              }
 788   2                              break;
 789   2                              #if 0
                              case OP_GEN_SEED:
                                      {
                                              memset(pu1Seed,0x00, SEED_LEN); 
                                              memcpy(out,g_u1SN, g_SNLen);
                                              memcpy(out+g_SNLen, g_u1SeedKey, SEEDKEY_LEN);
                                              SHA1Data(pu1Seed, out, g_SNLen+SEEDKEY_LEN);
                                              //while(1);
                                              //#if(DEBUG)
                                              //memset(pu1Seed,0x00, SEED_LEN);
                                              //for(i=0; i<20; i++)
                                              //{
                                              //      pu1Seed[i] = 0x30+((i+1)%10);
                                              //}
                                              //#endif
                                              
                                              u2Len = 32;
                                              for(i=0;i<16;i++) pu1MacKey[i] = g_u1Key[i];
                                              SM4_Init(pu1MacKey);
                                              SM4_Crypto(pu1Seed,u2Len,0x00,0x00,NULL,gUserInfo);     
                                              u1Rsp = OTPSECU_OP_OK;
                                              memset(pu1Seed,0x00,SEED_LEN);
                                                                              
                                      }
                                      break;
                                      #endif
 815   2                      case OP_TIME_TOKEN:
 816   2                              {
 817   3                                      memset(pu1DataBuf,0x00,6);
 818   3                                      GetTimeFactor(pu1TimeFactor);
 819   3                                      
 820   3                                      memcpy(pu1Seed,gUserInfo,SEED_LEN);
 821   3                                      
 822   3                                      for(i=0;i<KEY_LEN;i++) pu1MacKey[i] =g_u1Key[i];
 823   3                                      SM4_Init(pu1MacKey);
 824   3                                      SM4_Crypto(pu1Seed,SEED_LEN,0x01,0x00,NULL,pu1Seed);            //解密 seed
 825   3      
 826   3                                      u1Status =GenOtpOcra(pu1TimeFactor,TIME_LEN,pu1Seed,20,pu1DataBuf,6,pu1IV,&u1OLen);
 827   3                                      //while(1);
 828   3                                      memcpy(pu1DataBuf,pu1IV,u1OLen);
 829   3                                      memset(pu1Seed,0x00,SEED_LEN);  
 830   3                                      if ( 0x00==u1Status )
 831   3                                      {
 832   4                                              //for ( u1OLen=0; u1OLen<TIME_TOKEN_LEN; u1OLen++) pu1DataBuf[u1OLen] -= 0x30;          //显示的就是ASCLL码
 833   4                                              u1Rsp = OTPSECU_OP_OK;
 834   4                                      }
 835   3                                      else
 836   3                                      {
 837   4                                              u1Rsp = OTPSECU_OP_ERR;
 838   4                                      }
 839   3                                      break;
 840   3                              }
 841   2                              
 842   2                              default:
 843   2                              u1Rsp = OTPSECU_OP_ERR;
 844   2                              break;
 845   2              }
 846   1              
 847   1              vScu_SetSysClk32K();
C51 COMPILER V9.01   OTPFUNC                                                               11/23/2016 11:58:14 PAGE 15  

 848   1              return u1Rsp;
 849   1      }
 850          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3767    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     88     329
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
