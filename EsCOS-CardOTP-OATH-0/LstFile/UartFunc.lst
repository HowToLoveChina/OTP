C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE UARTFUNC
OBJECT MODULE PLACED IN .\ObjFile\UartFunc.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Func\UartFunc.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFile
                    -\Frame\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PRI
                    -NT(.\LstFile\UartFunc.lst) OBJECT(.\ObjFile\UartFunc.obj)

line level    source

   1          /********************************************************************
   2                                    Nationz Co.,Ltd
   3                  Copyright (c) 2009－2015 All Rights Reserved
   4           ********************************************************************
   5          File: UartFunc.c
   6          History：
   7          Version                      Author                     Date
   8          V0.1                         nationz              2013-03-27
   9          
  10          Description:
  11               UartFunc Source Code File;
  12          Function list:
  13              void vUartInit(void);
  14              UINT8 ucUartGetByte(void);
  15              void vUartPutByte(UINT8 Byte); 
  16                  void vUartSendData(UINT8 xdata *OutData,UINT16 Len); 
  17                  void vUartRecvData(UINT8 xdata *InData,UINT16 Len);      
  18          Special statement:
  19               NULL
  20           *******************************************************************/
  21          #define _UARTFUNC_C_
  22          #include "IOMFUNC.H"
  23          #include "SCUFUNC.H"
  24          #include "UartFunc.h"
  25          #include "string.H"
  26          #include "SM4.h"
  27          #include "OTPFRAME.H"
  28          #include "UARTFRAME.H"
  29          #include "SM4Process.h"
  30          #include "TimerFunc.h"
  31          #include "LcdFunc.h"
  32          #include "TBCFUNC.H"
  33          
  34          //u1  g_UART_COM_BUF[64];
  35          u1 ReceiveCompleteFlag;
  36          //u1 UARTBufferIndex;
  37          u1 u1UsartBuffer[50];
  38          
  39          const   u1      code AText[]    ={"OCRA-1:HOTP-SHA1-8:QA16-PSHA1-T1M"};
  40          const   u1  code g_u1PriKey[16] = {0x53,0x66,0x47,0xcf,0x5a,0xb0,0x51,0x1d,0x81,0x03,0xfe,0xe9,0x74,0x5f,0
             -x17,0x34};
  41          
  42          UINT32 ulGetTbcCountVlaue(void)
  43          {
  44   1              u1 u1TBCDR3Cnt;
  45   1              u1 u1TBCDR2Cnt;
  46   1              u1 u1TBCDR1Cnt;
  47   1              u1 u1TBCDR0Cnt;
  48   1              u4 u4Temp; 
  49   1      
  50   1      _START:
  51   1              u1TBCDR3Cnt = TBCDR3;
  52   1              u1TBCDR2Cnt = TBCDR2;
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 2   

  53   1      
  54   1              if(u1TBCDR3Cnt == TBCDR3)
  55   1              {
  56   2                      u1TBCDR1Cnt = TBCDR1;
  57   2                      if(u1TBCDR2Cnt == TBCDR2)
  58   2                      {
  59   3                              u1TBCDR0Cnt = TBCDR0;
  60   3                              if(u1TBCDR1Cnt != TBCDR1)
  61   3                              {
  62   4                                      u1TBCDR0Cnt = TBCDR0;
  63   4                              }
  64   3                      }
  65   2                      else
  66   2                      {
  67   3                              goto _START;
  68   3                      }
  69   2              }
  70   1              else
  71   1              {
  72   2                      goto _START;
  73   2              }
  74   1      
  75   1              u4Temp = ((((UINT32)u1TBCDR3Cnt<<24)&0xff000000)|(((UINT32)u1TBCDR2Cnt<<16)&0x00ff0000)|(((UINT32)u1TBCDR
             -1Cnt << 8) & 0x0000FF00) | u1TBCDR0Cnt);
  76   1              return u4Temp;          
  77   1      }
  78          
  79          void GETOTPTime(UINT8 *Time)
  80          {
  81   1              u2 k;
  82   1              u4 u4CrruentTime;
  83   1              u4CrruentTime = Base_Time();    
  84   1              u4CrruentTime += gTimer_Count_Base ;
  85   1              u4CrruentTime /=60;
  86   1      
  87   1              u4CrruentTime -= BASE_2011MINUTES;
  88   1      
  89   1              #if 1
  90   1              k       =2011;
  91   1              while( u4CrruentTime > 525600ul)
  92   1              {
  93   2                      u4CrruentTime   -= 525600ul;  //365*24*60
  94   2                      if((k&0x03)==0)
  95   2                      {
  96   3                              u4CrruentTime   -=1440ul; //24*60
  97   3                      }
  98   2                      k++;
  99   2              }
 100   1              #endif
 101   1      
 102   1              *Time = k%2000;
 103   1              *(Time+1) = 1;
 104   1      
 105   1              if(u4CrruentTime>44640ul)
 106   1              {
 107   2                      u4CrruentTime   -=44640ul;    //31*24*60
 108   2                      *(Time+1) = 2;
 109   2              }
 110   1              else
 111   1              {
 112   2                      goto __Day;
 113   2              }
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 3   

 114   1      
 115   1              if((k&0x03)==0)
 116   1              {
 117   2                      if(u4CrruentTime > 41760ul)
 118   2                      {
 119   3                              u4CrruentTime   -=41760ul; //29*24*60
 120   3                              *(Time+1) = 3;
 121   3                      }
 122   2                      else
 123   2                      {
 124   3                              goto __Day;
 125   3                      }
 126   2              }
 127   1              else
 128   1              {
 129   2                      if(u4CrruentTime > 40320ul)
 130   2                      {
 131   3                              u4CrruentTime   -=40320ul; //28*24*60
 132   3                              *(Time+1) = 3;
 133   3                      }
 134   2                      else
 135   2                      {
 136   3                              goto __Day;
 137   3                      }
 138   2              }
 139   1      
 140   1      
 141   1              if(u4CrruentTime>44640ul)
 142   1              {
 143   2                      u4CrruentTime   -=44640ul;    //31*24*60
 144   2                      *(Time+1) = 4;
 145   2              }
 146   1              else
 147   1              {
 148   2                      goto __Day;
 149   2              }
 150   1              
 151   1              if(u4CrruentTime>43200ul)
 152   1              {
 153   2                      u4CrruentTime   -=43200ul;    //30*24*60
 154   2                      *(Time+1) = 5;
 155   2              }
 156   1              else
 157   1              {
 158   2                      goto __Day;
 159   2              }
 160   1      
 161   1              if(u4CrruentTime>44640ul)
 162   1              {
 163   2                      u4CrruentTime   -=44640ul;    //31*24*60
 164   2                      *(Time+1) = 6;
 165   2              }
 166   1              else
 167   1              {
 168   2                      goto __Day;
 169   2              }
 170   1      
 171   1              if(u4CrruentTime>43200ul)
 172   1              {
 173   2                      u4CrruentTime   -=43200ul;    //30*24*60
 174   2                      *(Time+1) = 7;
 175   2              }
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 4   

 176   1              else
 177   1              {
 178   2                      goto __Day;
 179   2              }
 180   1      
 181   1              if(u4CrruentTime>44640ul)
 182   1              {
 183   2                      u4CrruentTime   -=44640ul;    //31*24*60
 184   2                      *(Time+1) = 8;
 185   2              }
 186   1              else
 187   1              {
 188   2                      goto __Day;
 189   2              }
 190   1      
 191   1              if(u4CrruentTime>44640ul)
 192   1              {
 193   2                      u4CrruentTime   -=44640ul;    //31*24*60
 194   2                      *(Time+1) = 9;
 195   2              }
 196   1              else
 197   1              {
 198   2                      goto __Day;
 199   2              }
 200   1      
 201   1              if(u4CrruentTime>43200ul)
 202   1              {
 203   2                      u4CrruentTime   -=43200ul;    //30*24*60
 204   2                      *(Time+1) = 10;
 205   2              }
 206   1              else
 207   1              {
 208   2                      goto __Day;
 209   2              }
 210   1      
 211   1              if(u4CrruentTime>44640ul)
 212   1              {
 213   2                      u4CrruentTime   -=44640ul;    //31*24*60
 214   2                      *(Time+1) = 11;
 215   2              }
 216   1              else
 217   1              {
 218   2                      goto __Day;
 219   2              }
 220   1      
 221   1              if(u4CrruentTime>43200ul)
 222   1              {
 223   2                      u4CrruentTime   -=43200ul;    //30*24*60
 224   2                      *(Time+1) = 12;
 225   2              }
 226   1      
 227   1              __Day:
 228   1      
 229   1              *(Time+2) = (u1)(u4CrruentTime/1440)+1;                 //day
 230   1              u4CrruentTime  = u4CrruentTime%1440;            //-= (*(Time+2)-1) * 1440;
 231   1              *(Time+3) = u4CrruentTime/60;                                   //hours
 232   1              *(Time+4) = u4CrruentTime%60;                                   //min
 233   1              //*(Time+5) = (gTimer_Count_Base + TBC_COUNT_VALUE)%60;         //sec
 234   1              u4CrruentTime = Base_Time();    
 235   1              u4CrruentTime += gTimer_Count_Base ;
 236   1              u4CrruentTime %=60;
 237   1              *(Time+5) = (u1)u4CrruentTime;
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 5   

 238   1                      
 239   1      }
 240          
 241          
 242          //#define _UART_INTER_EN_
 243          /********************************************************************
 244          Function name:       vUartInit
 245          Input parameters:
 246              void
 247          Return:
 248              void
 249          Function:
 250              Enable UART Module.
 251          ********************************************************************/
 252          void vUartInit(void)
 253          {
 254   1          vScu_IomClkEn();
 255   1              vIom_UartEn();
 256   1              vScu_UartClkEn();
 257   1              UARTCON=0x00;
 258   1              UARTSTAT=0xff;
 259   1      
 260   1              
 261   1      #ifdef _UART_INTER_EN_
                      //中断接收使能  
                      UARTCON|=UARTTS;
                      UARTCON|=0x01;
                      //唤醒使能
                      vScu_UartWakeupEn();
              
                      vScu_UartIntEn();
                      ES=1;
                      EA=1;
              #endif
 272   1      }
 273          /********************************************************************
 274          Function name:       ucUartGetByte
 275          Input parameters:
 276              void
 277          Return:
 278              UINT8 ：Data from Uart
 279          Function:
 280              Get One Byte from UART Interface.
 281          ********************************************************************/
 282          
 283          UINT8 ucUartGetByte(void)
 284          {
 285   1              UARTCON|=UARTTS;
 286   1              UARTCON|=0x01;
 287   1              while(!(UARTSTAT&RXFULSTAT));
 288   1              UARTSTAT|=RXFULSTAT;
 289   1              UARTCON=0x00;
 290   1              return ((UINT8)UARTBUF);
 291   1      }
 292          
 293          /********************************************************************
 294          Function name:       vUartPutByte
 295          Input parameters:
 296              UINT8 Byte：Send Data
 297          Return:
 298              void
 299          Function:
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 6   

 300              Send One Byte to UART Interface.
 301          ********************************************************************/
 302          void vUartPutByte(UINT8 Byte)
 303          {  
 304   1      #ifdef _UART_INTER_EN_
                      //中断接收关闭  
                      vScu_UartIntDis();
                      ES=0;
              #endif 
 309   1          UARTCON=0x00;
 310   1               
 311   1              UARTCON&=0xfd;
 312   1              UARTBUF=Byte;
 313   1              UARTCON|=0x01;
 314   1              while(UARTCON&0x01);
 315   1              UARTCON=0x00; 
 316   1              
 317   1      #ifdef _UART_INTER_EN_
                      //中断接收使能  
                      UARTCON|=UARTTS;
                      UARTCON|=0x01;
                      vScu_UartIntEn();
                      ES=1;
              #endif
 324   1                      
 325   1      }
 326          /********************************************************************
 327          Function name:       vUartSendData
 328          Input parameters:
 329              UINT8 xdata *OutData：Send Data 
 330                  UINT16 Len : Send Data length
 331          Return:
 332              void
 333          Function:
 334              Send Specify length Data to UART Interface.
 335          ********************************************************************/
 336          
 337          void vUartSendData(UINT8 *OutData,UINT16 Len)
 338          {
 339   1          UINT16 TmpLen;
 340   1              TmpLen=Len;                             //Len-1;
 341   1              UARTCON&=0xfd;
 342   1              //UARTBUF=*OutData++;           //test
 343   1              //UARTCON|=0x01;                        //test
 344   1              while(TmpLen--)
 345   1              {       
 346   2                      UARTBUF=*OutData++;     
 347   2                      UARTCON|=0x01;                  //test
 348   2                      while((UARTSTAT&TXFULSTAT));
 349   2                      //UARTBUF=*OutData++;   //test  
 350   2              }
 351   1              while(UARTCON&0x01);
 352   1              UARTCON=0x00; 
 353   1      }
 354          
 355          #if 0
              /********************************************************************
              Function name:       vUartRecvData
              Input parameters:
                  UINT8 xdata *InData：Pointer of the Receive Data Saved
                      UINT16 Len : Receive Data length
              Return:
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 7   

                  void
              Function:
                  Receive Specify length Data from UART Interface.
              ********************************************************************/
              void vUartRecvData(UINT8 xdata *InData,UINT16 Len)
              {
                      UARTCON|=UARTTS;
                      UARTCON|=0x01;
                      while(Len--)
                      {
                              while(!(UARTSTAT&RXFULSTAT));               
                              *InData++=UARTBUF;
                              UARTSTAT|=RXFULSTAT;                            //老版本的是去掉的
                      }
                      UARTCON=0x00;
              }
              #endif
 379          
 380          u2 ReceiveData_Poll(void)                                       //用TBC来做超时
 381          {
 382   1              u1 i;
 383   1              u1 u1MacChk;
 384   1              u1 u1RevDataFlag;
 385   1              u2 u2Status;
 386   1              u1      pu1IV[16];
 387   1              u2      u2Len;
 388   1              u1 pu1MacKey[16];
 389   1              u1 u1Index;
 390   1              //u1 u1ReceData;
 391   1      
 392   1              memset(g_UART_COM_BUF, 0x00, 64);
 393   1              
 394   1              //vScu_TbcIntEn();                              //超时用TBC
 395   1              gSecCount_10S=0;
 396   1              
 397   1              //timer0 配置
 398   1              ReceiveCompleteFlag = 0;
 399   1              #if 0
                      vTimer0_Stop();
                      //vScu_TimerClkEn();
                      vScu_Timer1ClkEn();             
                      //vTimer1Start(0,TIMER_MODE2,0x8000,TM1_32KEN);
                       vTimerClkSel(0,TM2_32KEN);     
                                         
                      TM1MOD = 0x00;                          // timer mod
                      TM0CDATA= 0xFE; 
                      vTimer0_CounterClr() ;
                      TM0CON = 0x01;                          //time2 start
                      //vTimer2_Start();
                      
                       vScu_Timer0IntEn();
                       vScu_Timer0WakeupEn();
                      #endif
 415   1              vTimer0_Stop();
 416   1              vTimer1Start(0,TIMER_MODE2,0x00fe,TM1_32KEN);   //定时1S
 417   1               
 418   1              EX1=1;
 419   1              EA=1;
 420   1              
 421   1              UARTCON|=UARTTS;                                                //选择接受模式
 422   1              UARTCON|=0x01;                                                  //使能串口
 423   1      
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 8   

 424   1      #if 1
 425   1              i = 0;
 426   1              while((!(UARTSTAT&RXFULSTAT))&&(gSecCount_10S < 120))                           //120s超时
 427   1              {
 428   2                      TM0CON = 0x00;                          //time2 stop
 429   2                      //TM0CDATA= 0xf8;
 430   2                      vTimer0_CounterClr() ;
 431   2                      TM0CON = 0x01;                          //time2 start
 432   2              }
 433   1              if(gSecCount_10S == 120)
 434   1              {
 435   2                      u2Status =RSP_REV_TIMEOUT;                        
 436   2                      vScu_TbcIntDis();
 437   2                      return u2Status;
 438   2              }
 439   1              
 440   1              while((ReceiveCompleteFlag == 0)&&(i < 64))                     //错误标志没有处理
 441   1              {
 442   2                      g_UART_COM_BUF[i++]=UARTBUF;                    // must here 
 443   2                      TM0CON = 0x00;                          //time2 stop
 444   2                      //TM0CDATA= 0xf8;
 445   2                      vTimer0_CounterClr() ;
 446   2                      TM0CON = 0x01;                          //time2 start
 447   2                      
 448   2                      while(!(UARTSTAT&RXFULSTAT))
 449   2                      {
 450   3                              if(ReceiveCompleteFlag == 1)
 451   3                              {
 452   4                                      break;
 453   4                              }
 454   3                      }       
 455   2              }
 456   1              
 457   1              UARTCON=0x00;
 458   1      
 459   1              TM0CON = 0x00;                          //time2 stop
 460   1              vTimer0_CounterClr() ;
 461   1              vScu_Timer0IntDis();
 462   1              vScu_Timer1ClkDis();    
 463   1              vScu_TbcIntDis();
 464   1      
 465   1              //if((ReceiveCompleteFlag == 1)||(UARTSTAT&0x07))
 466   1              //{
 467   1              //      return RSP_RECEIVE_ERR;
 468   1              //}
 469   1      
 470   1              u1Index = 0;
 471   1              u1RevDataFlag = 0;
 472   1              while((u1Index < i))
 473   1              {
 474   2                      if(SYN_BYTE == g_UART_COM_BUF[u1Index++])
 475   2                      {
 476   3                              u1RevDataFlag++;
 477   3                      }
 478   2                      else
 479   2                      {
 480   3                              u1RevDataFlag = 0;
 481   3                      }
 482   2      
 483   2                      if(u1RevDataFlag == 3)
 484   2                      {
 485   3                              break;
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 9   

 486   3                      }
 487   2              }
 488   1      
 489   1              if(u1Index == i)return RSP_DATA_ERR;                            //防止数据传错
 490   1      
 491   1              u1MacChk = 0;
 492   1              for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 493   1              memset(pu1IV, 0x00, 0x10);
 494   1              u2Len = g_UART_COM_BUF[OFFSET_LEN + u1Index]+0x02;
 495   1              AlgSymmMacFun2(&g_UART_COM_BUF[u1Index], &u2Len, pu1MacKey,pu1IV);
 496   1              u2Len = g_UART_COM_BUF[OFFSET_LEN + u1Index]+0x02;
 497   1              if (0 != memcmp(g_UART_COM_BUF+u2Len+u1Index,pu1IV,4)) u1MacChk =0x01;
 498   1      
 499   1              if(u1MacChk)
 500   1              {
 501   2                      u2Status =RSP_CHK_FAIL;
 502   2              }
 503   1              else
 504   1              {
 505   2                      u2Status =RSP_SET_SUCCESS;
 506   2                      for(i = 0; i< u2Len+4; i++)
 507   2                      {
 508   3                              g_UART_COM_BUF[i] = g_UART_COM_BUF[i+u1Index];
 509   3                      }
 510   2              }
 511   1      
 512   1              return u2Status;
 513   1      #endif
 514   1      
 515   1      }
 516          
 517          
 518          
 519          void USART_TxRsp(u2 u2Rsp,u1 u1Opcode)
 520          {
 521   1              //u2 u2CRC16Val;
 522   1              //u1 u1UsartBuffer[27];
 523   1              u1 pu1MacKey[16];
 524   1              u1 pu1IV[16];
 525   1          u1 i;
 526   1              u2 u2Len;
 527   1              //u1 u1Temp;
 528   1              //u4 u4Val;
 529   1              u1 pu1Seed[32];
 530   1              //u1 u1Tmp[48];
 531   1              
 532   1              //ConfigSysClkHigh();
 533   1              u1UsartBuffer[0] = 0x55;
 534   1              u1UsartBuffer[1] = 0x55;
 535   1              u1UsartBuffer[2] = 0x55;
 536   1              u1UsartBuffer[3] = u1Opcode;
 537   1      
 538   1              //vScu_SetSysClkOsc2M();
 539   1              if(u2Rsp == RSP_SET_SUCCESS)
 540   1              {
 541   2                      if(u1Opcode == OPCODE_READ_CALIB)
 542   2                      {
 543   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x03 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 544   3                              {
 545   4                                      u1UsartBuffer[4] = 0x02;
 546   4                                      if(gCalibflag == 1)
 547   4                                      {
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 10  

 548   5                                      if(Bak_PPMValue&0x8000)
 549   5                                      {
 550   6                                              u1UsartBuffer[5]=(UINT8)((0x7FFF-(Bak_PPMValue&0x7FFF))>>8);    
 551   6                                      u1UsartBuffer[6]=(UINT8)((0x7FFF-(Bak_PPMValue&0x7FFF))); 
 552   6                                      }
 553   5                                      else
 554   5                                      {
 555   6                                              u1UsartBuffer[5]=(UINT8)((0x7FFF+Bak_PPMValue)>>8);     
 556   6                                      u1UsartBuffer[6]=(UINT8)((0x7FFF+Bak_PPMValue)); 
 557   6                                      }
 558   5                                      }
 559   4                                      else
 560   4                                      {
 561   5                                              u1UsartBuffer[5] = 0xFF;
 562   5                                              u1UsartBuffer[6] = 0xFF;
 563   5                                      }
 564   4                                      u1UsartBuffer[7] = (u1)(u2Rsp>>8);
 565   4                                      u1UsartBuffer[8] = (u1)u2Rsp;
 566   4                                      
 567   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 568   4                                      memset(pu1IV, 0x00, 0x10);
 569   4                                      u2Len = 0x06;
 570   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 571   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 572   4                                      u1UsartBuffer[9] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 573   4                                      u1UsartBuffer[10] = pu1IV[1];//(u1)u2CRC16Val;
 574   4                                      u1UsartBuffer[11] = pu1IV[2];
 575   4                                      u1UsartBuffer[12] = pu1IV[3];
 576   4                                      vUartSendData(u1UsartBuffer,13);
 577   4                                      
 578   4                                      
 579   4                              }
 580   3                              else
 581   3                              {
 582   4                                      u2Rsp = RSP_DATA_ERR;
 583   4                                      u1UsartBuffer[4] = 0x00;
 584   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 585   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 586   4                                      // 计算MAC
 587   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 588   4                                      memset(pu1IV, 0x00, 0x10);
 589   4                                      u2Len = 0x04;
 590   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 591   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 592   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 593   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 594   4                                      u1UsartBuffer[9] = pu1IV[2];
 595   4                                      u1UsartBuffer[10] = pu1IV[3];
 596   4                                      vUartSendData(u1UsartBuffer,11);
 597   4                              }
 598   3                      }
 599   2                      else if(u1Opcode == OPCODE_READ_STATUS)
 600   2                      {
 601   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x01 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 602   3                              {
 603   4                                      u1UsartBuffer[4] = 0x01;
 604   4                                      u1UsartBuffer[5] = gUseCase;                    //gBlkCheckFlag.u1CheckStatus;
 605   4                                      u1UsartBuffer[6] = (u1)(u2Rsp>>8);
 606   4                                      u1UsartBuffer[7] = (u1)u2Rsp;
 607   4                                      
 608   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 609   4                                      memset(pu1IV, 0x00, 0x10);
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 11  

 610   4                                      u2Len = 0x05;
 611   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 612   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 613   4                                      u1UsartBuffer[8] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 614   4                                      u1UsartBuffer[9] = pu1IV[1];//(u1)u2CRC16Val;
 615   4                                      u1UsartBuffer[10] = pu1IV[2];
 616   4                                      u1UsartBuffer[11] = pu1IV[3];
 617   4                                      vUartSendData(u1UsartBuffer,12);
 618   4                              }
 619   3                              else
 620   3                              {
 621   4                                      u2Rsp = RSP_DATA_ERR;
 622   4                                      u1UsartBuffer[4] = 0x00;
 623   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 624   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 625   4                                      // 计算MAC
 626   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 627   4                                      memset(pu1IV, 0x00, 0x10);
 628   4                                      u2Len = 0x04;
 629   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 630   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 631   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 632   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 633   4                                      u1UsartBuffer[9] = pu1IV[2];
 634   4                                      u1UsartBuffer[10] = pu1IV[3];
 635   4                                      vUartSendData(u1UsartBuffer,11);
 636   4                              }
 637   3                      }
 638   2                      else if(u1Opcode==OPCODE_MK_SK)
 639   2                      {
 640   3                              u1UsartBuffer[4] = 0x04;
 641   3      
 642   3                              //if(g_SNLen<16)
 643   3                              //{
 644   3                              //      for(i=0; i<16-g_SNLen; i++)                     //bu ling
 645   3                              //      {
 646   3                              //              u1Tmp[i] = 0x30;
 647   3                              //      }
 648   3                              //}
 649   3                              //memcpy(u1Tmp+i, g_u1SN, g_SNLen);
 650   3                              //memcpy(u1UsartBuffer+21, g_u1SeedKey, KEY_LEN);
 651   3                              vScu_SetSysClkOsc2M();
 652   3                              memcpy(pu1Seed,gUserInfo,SEED_LEN);
 653   3                              for(i=0;i<KEY_LEN;i++) pu1MacKey[i] =g_u1Key[i];
 654   3                              SM4_Init(pu1MacKey);
 655   3                              SM4_Crypto(pu1Seed,SEED_LEN,0x01,0x00,NULL,pu1Seed);            //解密 seed
 656   3      
 657   3                              //memcpy(u1Tmp+16, pu1Seed, 32);
 658   3                              
 659   3                              
 660   3                              for(i=0;i<16;i++) pu1MacKey[i] =g_u1MacKey[i];
 661   3                              memset(pu1IV, 0x00, 0x10);
 662   3                              u2Len = 32;
 663   3                              //while(1);
 664   3                              AlgSymmMacFun2(pu1Seed, &u2Len, pu1MacKey, pu1IV);
 665   3                              u1UsartBuffer[5] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 666   3                              u1UsartBuffer[6] = pu1IV[1];//(u1)u2CRC16Val;
 667   3                              u1UsartBuffer[7] = pu1IV[2];
 668   3                              u1UsartBuffer[8] = pu1IV[3];
 669   3                              //while(1);
 670   3                              
 671   3                              u1UsartBuffer[9] = (u1)(u2Rsp>>8);
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 12  

 672   3                              u1UsartBuffer[10] = (u1)u2Rsp;
 673   3                              
 674   3                              for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 675   3                              memset(pu1IV, 0x00, 0x10);
 676   3                              u2Len = 0x08;
 677   3                              AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 678   3                              //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 679   3                              u1UsartBuffer[11] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 680   3                              u1UsartBuffer[12] = pu1IV[1];//(u1)u2CRC16Val;
 681   3                              u1UsartBuffer[13] = pu1IV[2];
 682   3                              u1UsartBuffer[14] = pu1IV[3];
 683   3                              vUartSendData(u1UsartBuffer,15);
 684   3                      }
 685   2                      else if(u1Opcode == OPCODE_READ_SN)
 686   2                      {
 687   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x05 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 688   3                              {                                                                                       
 689   4                                      u1UsartBuffer[4] = g_SNLen;
 690   4                                      for(i = 0; i < g_SNLen; i++)
 691   4                                      {
 692   5                                              u1UsartBuffer[5 + i] = g_u1SN[i] - 0x30;//用老版本的写入SN是要减去0x30的
 693   5                                      }
 694   4                                      
 695   4                                      u1UsartBuffer[g_SNLen+5] = (u1)(u2Rsp>>8);
 696   4                                      u1UsartBuffer[g_SNLen+6] = (u1)u2Rsp;
 697   4                                      
 698   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 699   4                                      memset(pu1IV, 0x00, 0x10);
 700   4                                      u2Len = g_SNLen+4;
 701   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 702   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 703   4                                      u1UsartBuffer[g_SNLen+7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 704   4                                      u1UsartBuffer[g_SNLen+8] = pu1IV[1];//(u1)u2CRC16Val;
 705   4                                      u1UsartBuffer[g_SNLen+9] = pu1IV[2];
 706   4                                      u1UsartBuffer[g_SNLen+10] = pu1IV[3];
 707   4                                      vUartSendData(u1UsartBuffer,g_SNLen+11);  
 708   4                              }
 709   3                              else
 710   3                              {
 711   4                                      u2Rsp = RSP_DATA_ERR;
 712   4                                      u1UsartBuffer[4] = 0x00;
 713   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 714   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 715   4                                      // 计算MAC
 716   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 717   4                                      memset(pu1IV, 0x00, 0x10);
 718   4                                      u2Len = 0x04;
 719   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 720   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 721   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 722   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 723   4                                      u1UsartBuffer[9] = pu1IV[2];
 724   4                                      u1UsartBuffer[10] = pu1IV[3];
 725   4                                      vUartSendData(u1UsartBuffer,11);
 726   4                              }
 727   3                      }
 728   2                      else if(u1Opcode == OPCODE_READ_TIME)
 729   2                      {
 730   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x06 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 731   3                              {
 732   4                                      u1UsartBuffer[4] = 0x06;
 733   4                                      GETOTPTime(&u1UsartBuffer[5]);
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 13  

 734   4                                      u1UsartBuffer[11] = (u1)(u2Rsp>>8);
 735   4                                      u1UsartBuffer[12] = (u1)u2Rsp;
 736   4                                      // 计算MAC
 737   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 738   4                                      memset(pu1IV, 0x00, 0x10);
 739   4                                      u2Len = 0x0A;
 740   4                                      //AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, ALGID_SMS4, ALG_MODE_MAC, pu1IV, 0x00, 0x01);
 741   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 742   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 743   4                                      u1UsartBuffer[13] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 744   4                                      u1UsartBuffer[14] = pu1IV[1];//(u1)u2CRC16Val;
 745   4                                      u1UsartBuffer[15] = pu1IV[2];
 746   4                                      u1UsartBuffer[16] = pu1IV[3];
 747   4                                      //USART_Cmd(USART_PORT, ENABLE);
 748   4                                      //SendMutliBytes(u1UsartBuffer,17);
 749   4                                      vUartSendData(u1UsartBuffer,17);
 750   4                              }
 751   3                              else
 752   3                              {
 753   4                                      u2Rsp = RSP_DATA_ERR;
 754   4                                      u1UsartBuffer[4] = 0x00;
 755   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 756   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 757   4                                      // 计算MAC
 758   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 759   4                                      memset(pu1IV, 0x00, 0x10);
 760   4                                      u2Len = 0x04;
 761   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 762   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 763   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 764   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 765   4                                      u1UsartBuffer[9] = pu1IV[2];
 766   4                                      u1UsartBuffer[10] = pu1IV[3];
 767   4                                      vUartSendData(u1UsartBuffer,11);
 768   4                              }
 769   3                      }
 770   2                      else if(u1Opcode == OPCODE_READ_VERSION)
 771   2                      {
 772   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x08 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 773   3                              {
 774   4                                      u1UsartBuffer[4] = 0x04;
 775   4                                      u1UsartBuffer[5] = 0x16;                                //15.08.13.01
 776   4                                      u1UsartBuffer[6] = 0x09;
 777   4                                      u1UsartBuffer[7] = 0x14;
 778   4                                      u1UsartBuffer[8] = 0xA3;
 779   4                                      u1UsartBuffer[9] = (u1)(u2Rsp>>8);
 780   4                                      u1UsartBuffer[10] = (u1)u2Rsp;
 781   4                                      
 782   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 783   4                                      memset(pu1IV, 0x00, 0x10);
 784   4                                      u2Len = 0x08;
 785   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 786   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 787   4                                      u1UsartBuffer[11] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 788   4                                      u1UsartBuffer[12] = pu1IV[1];//(u1)u2CRC16Val;
 789   4                                      u1UsartBuffer[13] = pu1IV[2];
 790   4                                      u1UsartBuffer[14] = pu1IV[3];
 791   4                                      vUartSendData(u1UsartBuffer,15);
 792   4                              }
 793   3                              else
 794   3                              {
 795   4                                      u2Rsp = RSP_DATA_ERR;
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 14  

 796   4                                      u1UsartBuffer[4] = 0x00;
 797   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 798   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 799   4                                      // 计算MAC
 800   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 801   4                                      memset(pu1IV, 0x00, 0x10);
 802   4                                      u2Len = 0x04;
 803   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 804   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 805   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 806   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 807   4                                      u1UsartBuffer[9] = pu1IV[2];
 808   4                                      u1UsartBuffer[10] = pu1IV[3];
 809   4                                      vUartSendData(u1UsartBuffer,11);
 810   4                              }
 811   3                      }
 812   2                      else if(u1Opcode == OPCODE_REQ_OK)
 813   2                      {
 814   3                              if((0xA0 == g_UART_COM_BUF[OFFSET_DATA])&&(0x02 == g_UART_COM_BUF[OFFSET_DATA + 1]))
 815   3                              {
 816   4                                      u1UsartBuffer[4] = 0x00;
 817   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 818   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 819   4                                      // 计算MAC
 820   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 821   4                                      memset(pu1IV, 0x00, 0x10);
 822   4                                      u2Len = 0x04;
 823   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 824   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 825   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 826   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 827   4                                      u1UsartBuffer[9] = pu1IV[2];
 828   4                                      u1UsartBuffer[10] = pu1IV[3];
 829   4                                      vUartSendData(u1UsartBuffer,11);
 830   4                                      //u2SubSec1 = RTC_GetSubSecond();
 831   4                              }
 832   3                              else
 833   3                              {
 834   4                                      u2Rsp = RSP_DATA_ERR;
 835   4                                      u1UsartBuffer[4] = 0x00;
 836   4                                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 837   4                                      u1UsartBuffer[6] = (u1)u2Rsp;
 838   4                                      // 计算MAC
 839   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 840   4                                      memset(pu1IV, 0x00, 0x10);
 841   4                                      u2Len = 0x04;
 842   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 843   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 844   4                                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 845   4                                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 846   4                                      u1UsartBuffer[9] = pu1IV[2];
 847   4                                      u1UsartBuffer[10] = pu1IV[3];
 848   4                                      vUartSendData(u1UsartBuffer,11);
 849   4                              }
 850   3                      }
 851   2                      else if(u1Opcode == OPCODE_SET_CALIB)
 852   2                      {
 853   3                              if(gCalibflag==1)
 854   3                              {
 855   4                                      u1UsartBuffer[4] = 0x02;
 856   4                                      if(Bak_PPMValue&0x8000)
 857   4                                      {
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 15  

 858   5                                              u1UsartBuffer[5]=(UINT8)((0x7FFF-(Bak_PPMValue&0x7FFF))>>8);    
 859   5                                              u1UsartBuffer[6]=(UINT8)((0x7FFF-(Bak_PPMValue&0x7FFF))); 
 860   5                                      }
 861   4                                      else
 862   4                                      {
 863   5                                              u1UsartBuffer[5]=(UINT8)((0x7FFF+Bak_PPMValue)>>8);     
 864   5                                              u1UsartBuffer[6]=(UINT8)((0x7FFF+Bak_PPMValue)); 
 865   5                                      }
 866   4                                      u1UsartBuffer[7] = (u1)(u2Rsp>>8);
 867   4                                      u1UsartBuffer[8] = (u1)u2Rsp;
 868   4                                      // 计算MAC
 869   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 870   4                                      memset(pu1IV, 0x00, 0x10);
 871   4                                      u2Len = 0x06;
 872   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 873   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 874   4                                      u1UsartBuffer[9] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 875   4                                      u1UsartBuffer[10] = pu1IV[1];//(u1)u2CRC16Val;
 876   4                                      u1UsartBuffer[11] = pu1IV[2];
 877   4                                      u1UsartBuffer[12] = pu1IV[3];
 878   4                                      vUartSendData(u1UsartBuffer,13);
 879   4                              }
 880   3                              else
 881   3                              {
 882   4                                      u1UsartBuffer[4] = 0x02;
 883   4                                      u1UsartBuffer[5] = 0xFF;
 884   4                                      u1UsartBuffer[6] = 0xFF;
 885   4                                      u1UsartBuffer[7] = (u1)(u2Rsp>>8);
 886   4                                      u1UsartBuffer[8] = (u1)u2Rsp;
 887   4                                      // 计算MAC
 888   4                                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 889   4                                      memset(pu1IV, 0x00, 0x10);
 890   4                                      u2Len = 0x06;
 891   4                                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 892   4                                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 893   4                                      u1UsartBuffer[9] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 894   4                                      u1UsartBuffer[10] = pu1IV[1];//(u1)u2CRC16Val;
 895   4                                      u1UsartBuffer[11] = pu1IV[2];
 896   4                                      u1UsartBuffer[12] = pu1IV[3];
 897   4                                      vUartSendData(u1UsartBuffer,13);
 898   4                              }
 899   3                      }
 900   2                      else if(u1Opcode == OPCPDE_READ_TEMP)                                   //SET_TEMP_BASIC
 901   2                      {
 902   3                              u1UsartBuffer[4] = 0x05;
 903   3                              if(Basic_Temp_Cmd==1)
 904   3                              {
 905   4                                      u1UsartBuffer[5]=(UINT8)(Basic_Temp_Value>>8);  
 906   4                                      u1UsartBuffer[6]=(UINT8)(Basic_Temp_Value); 
 907   4                                      u1UsartBuffer[7]=Real_Temp_Value_H;     
 908   4                                      u1UsartBuffer[8]=Real_Temp_Value_L; 
 909   4                                      #if(DEBUG)
                                              u1UsartBuffer[9] = 0;
                                              #else
 912   4                                      u1UsartBuffer[9] = Exral_Temp_Flag;
 913   4                                      #endif
 914   4                              }
 915   3                              else
 916   3                              {
 917   4                                      u1UsartBuffer[5] = 0xFF;
 918   4                                      u1UsartBuffer[6] = 0xFF;
 919   4                                      u1UsartBuffer[7] = 0xFF;
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 16  

 920   4                                      u1UsartBuffer[8] = 0xFF;
 921   4                                      u1UsartBuffer[9] = 0xff;
 922   4                              }
 923   3                              u1UsartBuffer[10] = (u1)(u2Rsp>>8);
 924   3                              u1UsartBuffer[11] = (u1)u2Rsp;
 925   3                              // 计算MAC
 926   3                              for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 927   3                              memset(pu1IV, 0x00, 0x10);
 928   3                              u2Len = 0x09;
 929   3                              AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 930   3                              //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 931   3                              u1UsartBuffer[12] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 932   3                              u1UsartBuffer[13] = pu1IV[1];//(u1)u2CRC16Val;
 933   3                              u1UsartBuffer[14] = pu1IV[2];
 934   3                              u1UsartBuffer[15] = pu1IV[3];
 935   3                              vUartSendData(u1UsartBuffer,16);
 936   3                      }               
 937   2                      else if(u1Opcode == OPCODE_CHANGE_STATUS)
 938   2                      {
 939   3                              u1UsartBuffer[4] = 0x01;
 940   3                              u1UsartBuffer[5] = gUseCase;                            //最新状态
 941   3                              u1UsartBuffer[6] = (u1)(u2Rsp>>8);
 942   3                              u1UsartBuffer[7] = (u1)u2Rsp;
 943   3                              
 944   3                              for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 945   3                              memset(pu1IV, 0x00, 0x10);
 946   3                              u2Len = 0x05;
 947   3                              AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 948   3                              //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 949   3                              u1UsartBuffer[8] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 950   3                              u1UsartBuffer[9] = pu1IV[1];//(u1)u2CRC16Val;
 951   3                              u1UsartBuffer[10] = pu1IV[2];
 952   3                              u1UsartBuffer[11] = pu1IV[3];
 953   3                              vUartSendData(u1UsartBuffer,12);
 954   3                      }
 955   2                      else
 956   2                      {
 957   3                              u1UsartBuffer[4] = 0x00;
 958   3                              u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 959   3                              u1UsartBuffer[6] = (u1)u2Rsp;
 960   3                              // 计算MAC
 961   3                              for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 962   3                              memset(pu1IV, 0x00, 0x10);
 963   3                              u2Len = 0x04;
 964   3                              AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey, pu1IV);
 965   3                              //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 966   3                              u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 967   3                              u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 968   3                              u1UsartBuffer[9] = pu1IV[2];
 969   3                              u1UsartBuffer[10] = pu1IV[3];
 970   3                              vUartSendData(u1UsartBuffer,11);
 971   3                              //u2SubSec1 = RTC_GetSubSecond();
 972   3                      }
 973   2              }
 974   1              else
 975   1              {
 976   2                      u1UsartBuffer[4] = 0x00;
 977   2                      u1UsartBuffer[5] = (u1)(u2Rsp>>8);
 978   2                      u1UsartBuffer[6] = (u1)u2Rsp;
 979   2                      // 计算MAC
 980   2                      for(i=0;i<16;i++) pu1MacKey[i] =g_u1PriKey[i];
 981   2                      memset(pu1IV, 0x00, 0x10);
C51 COMPILER V9.01   UARTFUNC                                                              11/23/2016 11:58:14 PAGE 17  

 982   2                      u2Len = 0x04;
 983   2                      AlgSymmMacFun2(&u1UsartBuffer[3], &u2Len, pu1MacKey,pu1IV);
 984   2                      //u2CRC16Val =CRC16Chk(&u1UsartBuffer[3],0x04);
 985   2                      u1UsartBuffer[7] = pu1IV[0];//(u1)(u2CRC16Val>>0x08);
 986   2                      u1UsartBuffer[8] = pu1IV[1];//(u1)u2CRC16Val;
 987   2                      u1UsartBuffer[9] = pu1IV[2];
 988   2                      u1UsartBuffer[10] = pu1IV[3];
 989   2                      vUartSendData(u1UsartBuffer,11);
 990   2              }
 991   1      
 992   1              memset(u1UsartBuffer,0x00,sizeof(u1UsartBuffer));
 993   1              //vScu_SetSysClk32K();
 994   1      }
 995          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6044    ----
   CONSTANT SIZE    =     50    ----
   XDATA SIZE       =     51     124
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
