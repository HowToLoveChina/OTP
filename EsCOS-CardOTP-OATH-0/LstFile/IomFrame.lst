C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE IOMFRAME
OBJECT MODULE PLACED IN .\ObjFile\IomFrame.obj
COMPILER INVOKED BY: H:\Keil\C51\BIN\C51.EXE SrcFile\Frame\IomFrame.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFil
                    -e\Frame\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PR
                    -INT(.\LstFile\IomFrame.lst) TABS(2) OBJECT(.\ObjFile\IomFrame.obj)

line level    source

   1          #define _IOMFRAME_C_
   2          #include "IOMFRAME.H"
   3          #include "IOMFUNC.H"
   4          #include "DEBUG.H"
   5          
   6          //UINT16 _TIMER_FLAG_;
   7          UINT16 _TIMER_FLAG_1_;
   8          
   9          void vKeboardInit(void)
  10          {
  11   1         vScu_IomClkEn();
  12   1         #if 1
  13   1         IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输入
  14   1         IOMP1PU=0xf0; //GP12-GP15上拉
  15   1         IOMP1PD=0x0f; //GP8-GP11下拉
  16   1           
  17   1         IOMP1INTS2=0xaa;//GP12-GP15下降沿中断使能//0xaa
  18   1         IOMP1INTS1=0x00; 
  19   1         IOMP1DOUT=0xF0;//GP8-GP11输出低  
  20   1        #endif
  21   1      
  22   1        #if 0
                 IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输?
                 IOMP1PU=0xb0; //GP12,GP13,GP15上拉
                 IOMP1PU=0x0f; //GP14下拉GP8-GP11下拉
                 
                 IOMP1PD=0xf0; //GP8-GP11上拉
                   
                 IOMP1INTS2=0x55;//GP12-GP15上降沿中断使能//0xaa
                 IOMP1INTS1=0x00; 
                 IOMP1DOUT=0xFF;//GP8-GP11输出高
                 #endif
  33   1      
  34   1         vScu_GpioWakeupEn();
  35   1         vScu_GpioIntEn();
  36   1         ES=1;
  37   1         EA=1;
  38   1      }
  39          
  40          UINT8 ucGetKeyValue(void)
  41          {
  42   1         static UINT8 KEY_STAT=0,KeyTmp[3]; 
  43   1         UINT8 i; 
  44   1         if(0x55==_KBC_INT_FLAG_)//在中断被置起
  45   1         {
  46   2              
  47   2              _KBC_INT_FLAG_=0x00;
  48   2          
  49   2            if(KEY_STAT==KEY_STAT_PRESS) //有按键按下，开启TIMER定时器
  50   2          { 
  51   3            LongPressFlag = 0;
  52   3               //vTimer1Start(0,TIMER_MODE2,0x8000,TM1_32KEN);  //定时1S
  53   3               _TIMER_FLAG_1_ = 0x00;           
C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 2   

  54   3             KeyTmp[0]=_IOM_FLAG_&0xF0;          
  55   3             _IOM_FLAG_=0x00;      
  56   3             if(0x00!=(KeyTmp[0]))
  57   3             {         
  58   4      
  59   4                 KEY_STAT=KEY_STAT_RELEASE;              
  60   4               IOMP1DIR=0xf0;//GP8-GP11输入，GP12-GP15输出
  61   4               IOMP1PU=0x0f; //GP8-GP11上拉
  62   4                        IOMP1PD=0xf0; //GP12-GP15下拉
  63   4      
  64   4      
  65   4               IOMP1INTS1=0x55;//GP8-GP11上升沿中断使能              
  66   4                     
  67   4               IOMP1INTS2=0x00;
  68   4               IOMP1DOUT=0x0f;//GP12-GP15输出低 
  69   4               
  70   4               vScu_GpioWakeupEn();
  71   4                        vScu_GpioIntEn();               
  72   4               
  73   4             }
  74   3             else
  75   3             {
  76   4                //vTimer0_Stop();
  77   4                _TIMER_FLAG_1_ = 0;
  78   4             }
  79   3             
  80   3          }
  81   2          else if(KEY_STAT==KEY_STAT_RELEASE)//按键释放
  82   2          {      
  83   3             //vTimer0_Stop();
  84   3             KeyTmp[1]=_IOM_FLAG_&0x0f;
  85   3             KEY_STAT=KEY_STAT_PRESS; 
  86   3              
  87   3            #if 1
  88   3             //IOMP1DOUT=0x00;//GP8-GP11输出低
  89   3             IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输入
  90   3                   IOMP1PU=0xf0; //GP12-GP15上拉
  91   3                   IOMP1PD=0x0f; //GP8-GP11下拉
  92   3             
  93   3                   IOMP1INTS2=0xaa;//GP12-GP15下降沿中断使能    //0xaa
  94   3                   IOMP1INTS1=0x00; 
  95   3                   IOMP1DOUT=0xF0;//GP8-GP11输出低    
  96   3                   #endif
  97   3      
  98   3             #if 0
                     IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输入
                     IOMP1PU=0x0f; //GP12-GP15下拉
                     IOMP1PD=0xf0; //GP8-GP11上拉
                       
                     IOMP1INTS2=0x55;//GP12-GP15上降沿中断使能//0xaa
                     IOMP1INTS1=0x00; 
                     IOMP1DOUT=0xFF;//GP8-GP11输出高
                     #endif
 107   3              
 108   3      
 109   3             _IOM_FLAG_=0x00;        
 110   3               
 111   3      
 112   3             if(_TIMER_FLAG_1_>=LONG_PRESS_TIME)   //长按
 113   3             {
 114   4                  _TIMER_FLAG_1_=0;
 115   4                for(i=0;i<16;i++)
C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 3   

 116   4                {
 117   5                    if((KeyTmp[1]|KeyTmp[0])==KeyTable[i]) 
 118   5                  {
 119   6                     //return (~(0x30+i));
 120   6                     LongPressFlag = 1;
 121   6                     return (0x30+i);
 122   6                  }
 123   5                }
 124   4                
 125   4             }
 126   3             else
 127   3             {
 128   4                  _TIMER_FLAG_1_=0;
 129   4                for(i=0;i<16;i++)
 130   4                {
 131   5                    if((KeyTmp[1]|KeyTmp[0])==KeyTable[i])
 132   5                  {
 133   6                     return (0x30+i);
 134   6                  }
 135   5                }
 136   4             }      
 137   3               
 138   3           }
 139   2           else
 140   2           {
 141   3               KEY_STAT=KEY_STAT_PRESS; 
 142   3               #if 1
 143   3                IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输入
 144   3                     IOMP1PU=0xf0; //GP12-GP15上拉
 145   3                     IOMP1PD=0x0f; //GP8-GP11下拉
 146   3               
 147   3                     IOMP1INTS2=0xaa;//GP12-GP15下降沿中断使能
 148   3                     IOMP1INTS1=0x00; 
 149   3                     IOMP1DOUT=0xF0;//GP8-GP11输出低
 150   3              #endif
 151   3      
 152   3              #if 0
                       IOMP1DIR=0x0f;//GP8-GP11输出，GP12-GP15输入
                       IOMP1PU=0x0f; //GP12-GP15下拉
                       IOMP1PD=0xf0; //GP8-GP11上拉
                         
                       IOMP1INTS2=0x55;//GP12-GP15上降沿中断使能//0xaa
                       IOMP1INTS1=0x00; 
                       IOMP1DOUT=0xFF;//GP8-GP11输出高
                       #endif
 161   3      
 162   3               //vTimer0_Stop();
 163   3      
 164   3               vScu_GpioIntEn();
 165   3               return 0xff;
 166   3           }
 167   2           
 168   2         }
 169   1         else
 170   1         {
 171   2              //超时处理，按键一直没有释放，关定时器，给出常按键值
 172   2           if(_TIMER_FLAG_1_>=PRESS_TIME_OUT)  //长按超时
 173   2           {
 174   3                
 175   3                //vTimer0_Stop();
 176   3              
 177   3              _TIMER_FLAG_1_=0;
C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 4   

 178   3              KEY_STAT=KEY_STAT_PRESS;
 179   3              _IOM_FLAG_=0;
 180   3               _KBC_INT_FLAG_=0x00;
 181   3      
 182   3              vKeboardInit(); 
 183   3              
 184   3              return(0x55);
 185   3           }
 186   2            //低功耗suspend MODE  
 187   2          //_KBC_INT_FLAG_=0x00;
 188   2          //vScu_SuspendModeEn(); 
 189   2              
 190   2          return 0xff;
 191   2         }
 192   1         return 0xff;
 193   1      
 194   1      }
 195          
 196          #if 0
              void vKeyboardTest(void)
              {
                  UINT8 TmpData;
                vKeboardInit();
                  while(1)
                  {
                   
                   //DebugPrintf("IOMP1DIN=%02bx\r\n",IOMP1DIN);
                     TmpData=ucGetKeyValue();
                     if(0xff!=TmpData)
                   {
                       DebugPrintf("TmpData=%02bx\r\n",TmpData);
                   }
                   else
                   {
                       //DebugPrintf("IOMP1DIN=%02bx\r\n",IOMP1DIN);
                     //DebugPrintf("TmpData=%02bx\r\n",TmpData);
                   }
                    
                  
                  }
              }
              
              
              
              void vIomVerify(void)
              {
                  //UINT8 TmpData;
                DebugPrintf("Call Function:vIomVerify() in File:(%s),Line:%d,\r\n", __FILE__,(UINT16)__LINE__);
                vScu_IomClkEn();
                switch(CMD_INS)
                {   
                  case 0x04:  //08 04 00 00 00 
                        vKeyboardTest();
                      break;
                  case 0x05:  //08 05 00 00 00
                   
                        IOMP1DIR=CMD_P1;//GP8-GP11输出，GP12-GP15输入 
                      DebugPrintf("IOMP1DIR=%02bx\r\n",IOMP1DIR);               
                      break;
                  case 0x06:  //08 06 00 00 00          
              
                          IOMP1DOUT=CMD_P1;//GP8-GP11输出低  
C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 5   

                      DebugPrintf("IOMP1DOUT=%02bx\r\n",IOMP1DOUT); 
                      break;
              
                  case 0x07:  //08 05 00 00 00
                   
                        IOMP1PU=CMD_P1;//GP8-GP11输出，GP12-GP15输入  
                      DebugPrintf("IOMP1PU=%02bx\r\n",IOMP1PU);               
                      break;
                  case 0x08:  //08 06 00 00 00          
              
                          IOMP1PD=CMD_P1;//GP8-GP11输出低  
                      DebugPrintf("IOMP1PD=%02bx\r\n",IOMP1PD); 
                      break;
              
                  case 0x09:  //08 05 00 00 00
                   
                        IOMP0DIR=CMD_P1;//GP8-GP11输出，GP12-GP15输入 
                      DebugPrintf("IOMP0DIR=%02bx\r\n",IOMP0DIR);               
                      break;
                  case 0x10:  //08 06 00 00 00          
              
                          IOMP0DOUT=CMD_P1;//GP8-GP11输出低  
                      DebugPrintf("IOMP0DOUT=%02bx\r\n",IOMP0DOUT); 
                      break;
                   case 0x11: //08 05 00 00 00
                   
                        IOMP0PU=CMD_P1;//GP8-GP11输出，GP12-GP15输入  
                      DebugPrintf("IOMP0PU=%02bx\r\n",IOMP0PU);               
                      break;
                  case 0x12:  //08 06 00 00 00          
              
                          IOMP0PD=CMD_P1;//GP8-GP11输出低  
                      DebugPrintf("IOMP0PD=%02bx\r\n",IOMP0PD); 
                      break;
                  case 0x13:  //08 06 00 00 00          
              
                          IOMCR=CMD_P1;//GP8-GP11输出低  
                      DebugPrintf("IOMCR=%02bx\r\n",IOMCR); 
                      break;
                  case 0x14:  //08 06 00 00 00
                            DebugPrintf("IOMCR=%02bx\r\n",IOMCR);
              
                        DebugPrintf("IOMP0DIR=%02bx\r\n",IOMP0DIR);           
                      DebugPrintf("IOMP0DOUT=%02bx\r\n",IOMP0DOUT);
                          DebugPrintf("IOMP0PU=%02bx\r\n",IOMP0PU);  
                      DebugPrintf("IOMP0PD=%02bx\r\n",IOMP0PD); 
              
                      DebugPrintf("IOMP1DIR=%02bx\r\n",IOMP1DIR);           
                      DebugPrintf("IOMP1DOUT=%02bx\r\n",IOMP1DOUT);
                          DebugPrintf("IOMP1PU=%02bx\r\n",IOMP1PU);  
                      DebugPrintf("IOMP1PD=%02bx\r\n",IOMP1PD);
                      break;
              
              
                   default:
                        DebugPrintf("vKeyboardTest!\r\n");
                        vKeyboardTest();
                        break;
                }
                DebugPrintf("************Excute CMD_INS:%02bx Over************\r\n",CMD_INS);
              }
              #endif
C51 COMPILER V9.00   IOMFRAME                                                              07/19/2016 16:59:04 PAGE 6   

 302          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    333    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
