C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SHA1
OBJECT MODULE PLACED IN .\ObjFile\Sha1.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SrcFile\Func\Sha1.c LARGE BROWSE INCDIR(.\SrcFile\StartUp\CPU;.\SrcFile\Fra
                    -me\Inc;.\SrcFile\Func\Inc;.\SrcFile\Lib;.\SrcFile\App\Inc) DEFINE(_DEV_BOARD_,_FPGA_DEMO_EN_) DEBUG OBJECTEXTEND PRINT(.
                    -\LstFile\Sha1.lst) OBJECT(.\ObjFile\Sha1.obj)

line level    source

   1          //#include "StdAfx.h"
   2          #include "SHA1.H"
   3          #include "string.h"
   4          
   5          #if 0
              static void sha1_transform(sha *sh)
              { /* basic transformation step */
                  unsigned int a,b,c,d,e,temp;
                  int t;
              
                  for (t=16;t<80;t++) sh->w[t]=S(1,sh->w[t-3]^sh->w[t-8]^sh->w[t-14]^sh->w[t-16]);
                  a=sh->h[0]; b=sh->h[1]; c=sh->h[2]; d=sh->h[3]; e=sh->h[4];
                  for (t=0;t<20;t++)
                  { /* 20 times - mush it up */
                      temp=K0+F0(b,c,d)+S(5,a)+e+sh->w[t];
                      e=d; d=c;
                      c=S(30,b);
                      b=a; a=temp;
                  }
                  for (t=20;t<40;t++)
                  { /* 20 more times - mush it up */
                      temp=K1+F1(b,c,d)+S(5,a)+e+sh->w[t];
                      e=d; d=c;
                      c=S(30,b);
                      b=a; a=temp;
                  }
                  for (t=40;t<60;t++)
                  { /* 20 more times - mush it up */
                      temp=K2+F2(b,c,d)+S(5,a)+e+sh->w[t];
                      e=d; d=c;
                      c=S(30,b);
                      b=a; a=temp;
                  }
                  for (t=60;t<80;t++)
                  { /* 20 more times - mush it up */
                      temp=K3+F3(b,c,d)+S(5,a)+e+sh->w[t];
                      e=d; d=c;
                      c=S(30,b);
                      b=a; a=temp;
                  }
                  sh->h[0]+=a; sh->h[1]+=b; sh->h[2]+=c;
                  sh->h[3]+=d; sh->h[4]+=e;
              } 
              
              void sha1_init(sha *sh)
              { /* re-initialise */
                  int i;
                      
                  for (i=0;i<80;i++) sh->w[i]=0L;
                  sh->length[0]=sh->length[1]=0L;
                      
                  sh->h[0]=H0;
                  sh->h[1]=H1;
C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 2   

                  sh->h[2]=H2;
                  sh->h[3]=H3;
                  sh->h[4]=H4;
              }
              
              void sha1_process(sha *sh,int byte)
              { /* process the next message byte */
                  int cnt;
                  
                  cnt=(int)((sh->length[0]/32)%16);
                  
                  sh->w[cnt]<<=8;
                  sh->w[cnt]|=(unsigned int)(byte&0xFF);
              
                  sh->length[0]+=8;
                  if (sh->length[0]==0L) { sh->length[1]++; sh->length[0]=0L; }
                  if ((sh->length[0]%512)==0) sha1_transform(sh);
              }
              
              void sha1_hash(sha *sh,char hash[20])
              { /* pad message and finish - supply digest */
                  int i;
                  unsigned int len0,len1;
                  len0=sh->length[0];
                  len1=sh->length[1];
                  sha1_process(sh,PAD);
                  while ((sh->length[0]%512)!=448) sha1_process(sh,ZERO);
                  sh->w[14]=len1;
                  sh->w[15]=len0;    
                  sha1_transform(sh);
                  for (i=0;i<20;i++)
                  { /* convert to bytes */
                      hash[i]=((sh->h[i/4]>>(8*(3-i%4))) & 0xffL);
                  }
                  sha1_init(sh);
              }
              
              // 计算SHA值，输出到pbHashValue指向的地址
              // 注意：缓冲区长度至少0x14字节
              void ComputeSHA1(const UINT8* pbData, UINT32 dwDataLen, UINT8* pbHashValue)
              {
                      sha sh;
                      char hash[20];
                      UINT32 i;
              
                      sha1_init(&sh);
                      for (i=0; i < dwDataLen; i++)
                      {
                              sha1_process(&sh, pbData[i]);
                      }
                      sha1_hash(&sh, hash);
                      memcpy(pbHashValue, hash, sizeof(hash));
              }
              
              #endif
 109          
 110          #define BYTE2LONG(pu1Data)                      (((u4)((pu1Data)[0])<<24) + ((u4)((pu1Data)[1])<<16) + ((u2)((pu1Data)[2])<<8
             -) + (u1)((pu1Data)[3]))
 111          #define BYTE2WORD(pu1Data)                      ((u2)(((u2)((pu1Data)[0])<<8) + (u1)((pu1Data)[1])))
 112          #define LONG2BYTE(pu1Data,u4Data)       ((u1*)(pu1Data))[0] = (u1)((u4Data)>>24);((u1*)(pu1Data))[1] = (u1)((u4D
             -ata)>>16);((u1*)pu1Data)[2] = (u1)((u4Data)>>8);((u1*)pu1Data)[3] = (u1)((u4Data))
 113          //#define WORD2BYTE(pu1Data,u2Data)     ((u1*)(pu1Data))[0] = (u1)((u2Data)>>8);((u1*)(pu1Data))[1] = (u1)((u2
C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 3   

             -Data))
 114          
 115          
 116          
 117          #ifdef _BIG_ENDIAN_
 118          #define longReverse(pvDst, pvSrc, u4Count)      memcpy(pvDst, pvSrc, u4Count<<2)
 119          #else
              void longReverse(void xdata* pvDst, const void xdata* pvSrc, u4 u4Count)
              {
                      u4      i;
                      u1      buf[4],tmp[4];
                      
                      u4Count <<= 0x02;
              
                      for ( i = 0x00; i < u4Count; i+=0x04)
                      {
                              memcpy(buf, (u1*)pvSrc + i, 4);
                              tmp[0]=buf[3];
                              tmp[1]=buf[2];
                              tmp[2]=buf[1];
                              tmp[3]=buf[0];
                              memcpy((u1*)pvDst + i,tmp,4);
                      }
              }
              #endif
 138          
 139          const   u1  code g_pu1Sha1DefaultIV[20] =
 140          {
 141                  0x67, 0x45, 0x23, 0x01, 0xef, 0xcd, 0xab, 0x89, 0x98, 0xba, 
 142                  0xdc, 0xfe, 0x10, 0x32, 0x54, 0x76, 0xc3, 0xd2, 0xe1, 0xf0
 143          };
 144          
 145          void vSha1GetDefaultIv(void xdata* pvIv)
 146          {
 147   1              memcpy(pvIv, g_pu1Sha1DefaultIV, 0x14);// T21移植时再确定在C51下是否能支持。
 148   1      }
 149          
 150          void SHA1_CycleCompute0(u4 xdata* pu4ABCDE, u4 xdata u4W)
 151          {
 152   1              u4              temp;
 153   1      
 154   1              temp = (pu4ABCDE[0]<<5 | pu4ABCDE[0]>>27) + pu4ABCDE[4] + u4W + 0x5a827999 
 155   1                       + (pu4ABCDE[1] & pu4ABCDE[2] | ~pu4ABCDE[1] & pu4ABCDE[3]);
 156   1      
 157   1              pu4ABCDE[4] = pu4ABCDE[3];
 158   1              pu4ABCDE[3] = pu4ABCDE[2];
 159   1              pu4ABCDE[2] = pu4ABCDE[1]<<30 | pu4ABCDE[1]>>2;
 160   1              pu4ABCDE[1] = pu4ABCDE[0];
 161   1              pu4ABCDE[0] = temp;
 162   1      }
 163          void SHA1_CycleCompute1(u4 xdata* pu4ABCDE, u4 xdata u4W)
 164          {
 165   1              u4              temp;
 166   1              
 167   1              temp = (pu4ABCDE[0]<<5 | pu4ABCDE[0]>>27) + pu4ABCDE[4] + u4W + 0x6ed9eba1 
 168   1                      + (pu4ABCDE[1] ^ pu4ABCDE[2] ^ pu4ABCDE[3]);
 169   1      
 170   1              pu4ABCDE[4] = pu4ABCDE[3];
 171   1              pu4ABCDE[3] = pu4ABCDE[2];
 172   1              pu4ABCDE[2] = pu4ABCDE[1]<<30 | pu4ABCDE[1]>>2;
 173   1              pu4ABCDE[1] = pu4ABCDE[0];
 174   1              pu4ABCDE[0] = temp;
C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 4   

 175   1      }
 176          void SHA1_CycleCompute2(u4 xdata* pu4ABCDE, u4 xdata u4W)
 177          {
 178   1              u4              temp;
 179   1              
 180   1              temp = (pu4ABCDE[0]<<5 | pu4ABCDE[0]>>27) + pu4ABCDE[4] + u4W + 0x8f1bbcdc 
 181   1                      + (pu4ABCDE[1] & pu4ABCDE[2] | pu4ABCDE[1] & pu4ABCDE[3] | pu4ABCDE[2] & pu4ABCDE[3]);
 182   1              
 183   1              pu4ABCDE[4] = pu4ABCDE[3];
 184   1              pu4ABCDE[3] = pu4ABCDE[2];
 185   1              pu4ABCDE[2] = pu4ABCDE[1]<<30 | pu4ABCDE[1]>>2;
 186   1              pu4ABCDE[1] = pu4ABCDE[0];
 187   1              pu4ABCDE[0] = temp;
 188   1      }
 189          void SHA1_CycleCompute3(u4 xdata* pu4ABCDE, u4 xdata u4W)
 190          {
 191   1              u4              temp;
 192   1              
 193   1              temp = (pu4ABCDE[0]<<5 | pu4ABCDE[0]>>27) + pu4ABCDE[4] + u4W + 0xca62c1d6 
 194   1                      + (pu4ABCDE[1] ^ pu4ABCDE[2] ^ pu4ABCDE[3]);
 195   1              
 196   1              pu4ABCDE[4] = pu4ABCDE[3];
 197   1              pu4ABCDE[3] = pu4ABCDE[2];
 198   1              pu4ABCDE[2] = pu4ABCDE[1]<<30 | pu4ABCDE[1]>>2;
 199   1              pu4ABCDE[1] = pu4ABCDE[0];
 200   1              pu4ABCDE[0] = temp;
 201   1      }
 202          
 203          void vSha1OneBlock(void xdata * pu1HashData,const void xdata * pu1Message)
 204          {
 205   1              u1      t;
 206   1              u4 xdata        pu4W[0x40];
 207   1              u4 xdata        pu4ABCDE[0x14];
 208   1              u4 xdata        u4Temp;
 209   1      
 210   1              //pu4W = MngAllocateBuff(0x40);
 211   1              //pu4ABCDE = MngAllocateBuff(0x14);
 212   1      
 213   1              // 注意，输入的参数可能不是四字节的整数倍，但是我们在内部运算的时候要用成四字节整数倍
 214   1              longReverse(pu4ABCDE, pu1HashData, 0x05);
 215   1      
 216   1              for ( t = 0; t < 16; t++ )
 217   1              {
 218   2                      pu4W[t] = BYTE2LONG(((u1*)pu1Message) + (t<<2));
 219   2                      SHA1_CycleCompute0(pu4ABCDE, pu4W[t]);
 220   2              }
 221   1              for (t = 16 ; t < 20; ++t) 
 222   1              {
 223   2                      u4Temp = pu4W[(t-3)&0x0F] ^ pu4W[(t-8)&0x0F] ^ pu4W[(t-14)&0x0F] ^ pu4W[t&0x0F];
 224   2                      pu4W[t&0x0F] = u4Temp<<1 | u4Temp>>31; 
 225   2                      SHA1_CycleCompute0(pu4ABCDE, pu4W[t&0x0F]);
 226   2              }
 227   1      
 228   1              for (t = 20 ; t < 40; ++t) 
 229   1              {
 230   2                      u4Temp = pu4W[(t-3)&0x0F] ^ pu4W[(t-8)&0x0F] ^ pu4W[(t-14)&0x0F] ^ pu4W[t&0x0F];
 231   2                      pu4W[t&0x0F] = u4Temp<<1 | u4Temp>>31; 
 232   2                      SHA1_CycleCompute1(pu4ABCDE, pu4W[t&0x0F]);
 233   2              }
 234   1      
 235   1              for (t = 40 ; t < 60; ++t) 
 236   1              {
C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 5   

 237   2                      u4Temp = pu4W[(t-3)&0x0F] ^ pu4W[(t-8)&0x0F] ^ pu4W[(t-14)&0x0F] ^ pu4W[t&0x0F];
 238   2                      pu4W[t&0x0F] = u4Temp<<1 | u4Temp>>31; 
 239   2                      SHA1_CycleCompute2(pu4ABCDE, pu4W[t&0x0F]);
 240   2              }
 241   1      
 242   1              for (t = 60 ; t < 80; ++t) 
 243   1              {
 244   2                      u4Temp = pu4W[(t-3)&0x0F] ^ pu4W[(t-8)&0x0F] ^ pu4W[(t-14)&0x0F] ^ pu4W[t&0x0F];
 245   2                      pu4W[t&0x0F] = u4Temp<<1 | u4Temp>>31; 
 246   2                      SHA1_CycleCompute3(pu4ABCDE, pu4W[t&0x0F]);
 247   2              }
 248   1              pu4ABCDE[0] += BYTE2LONG(((u1*)pu1HashData));
 249   1              pu4ABCDE[1] += BYTE2LONG(((u1*)pu1HashData) + 0x04);
 250   1              pu4ABCDE[2] += BYTE2LONG(((u1*)pu1HashData) + 0x08);
 251   1              pu4ABCDE[3] += BYTE2LONG(((u1*)pu1HashData) + 0x0C);
 252   1              pu4ABCDE[4] += BYTE2LONG(((u1*)pu1HashData) + 0x10);
 253   1      
 254   1              longReverse(pu1HashData, pu4ABCDE, 0x05);
 255   1      
 256   1              //MngFreeBuff(0x54);
 257   1              //vEnableLowPower(MOUDLE_SOFT_ALG);
 258   1              return;
 259   1      }
 260          
 261          void SHA1Data(u1 xdata* pu1Output, const u1 xdata* pu1Input, u2 u2DataSize)
 262          {
 263   1              u1 xdata        u1BlockSize;
 264   1              u1 xdata        u1IvSize;
 265   1              u4 xdata        u4DataSize;
 266   1              u1 xdata        pu1Temp[0x40];
 267   1      
 268   1              u4DataSize = (u2DataSize<<0x03);
 269   1              u1BlockSize = 0x40;
 270   1              u1IvSize = 0x14;
 271   1              //pu1Temp = (u1*)MngAllocateBuff(u1BlockSize);
 272   1              vSha1GetDefaultIv(pu1Output);
 273   1              while ( u2DataSize >= u1BlockSize )
 274   1              {
 275   2                      vSha1OneBlock(pu1Output, pu1Input);
 276   2                      pu1Input += u1BlockSize;
 277   2                      u2DataSize -= u1BlockSize;
 278   2              }
 279   1              memset(pu1Temp, 0x00, u1BlockSize);
 280   1              memcpy(pu1Temp, pu1Input, u2DataSize);
 281   1              pu1Temp[u2DataSize] = 0x80;
 282   1              if ( u2DataSize >= (u1)(u1BlockSize - (u1BlockSize>>3)) )
 283   1              {
 284   2                      vSha1OneBlock(pu1Output, pu1Temp);
 285   2                      memset(pu1Temp, 0x00, u1BlockSize);
 286   2              }
 287   1              {
 288   2      
 289   2                      LONG2BYTE(pu1Temp + u1BlockSize - 0x04,u4DataSize);
 290   2              }
 291   1              vSha1OneBlock(pu1Output, pu1Temp);
 292   1              //MngFreeBuff(u1BlockSize);
 293   1              return;
 294   1      }
 295          
 296          


C51 COMPILER V9.01   SHA1                                                                  11/23/2016 11:58:15 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5461    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =   ----     461
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
